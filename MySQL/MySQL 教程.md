# MySQL 教程

> **温馨提示**：用符号`[]`括起来的内容，表示可选项；符号`+`，则表示连接的意思。

## 1. 数据库

### 1.1 定义
--------

数据库，可以简单的解释为：**高效的存储和处理数据的介质（主要分为磁盘和内存两种）**。

### 1.2 分类
----

根据数据库存储介质的不同，可以将其分为两类，即：关系型数据库（SQL）和非关系型数据库（NoSQL，Not Only SQL）。

### 1.3 举例
----

关系型数据库：

 - 大型：Oracle、DB2 等；
 - 中型：SQL Server、MySQL 等；
 - 小型：Access 等。

非关系型数据库：

 - Memcached、MongoDB 和 Redis 等。

1.4 区别
----

关系型数据库：

 - 安全，其将数据保存到磁盘之中，基本不可能出现丢失数据的情况；
 - 比较浪费空间，因为其用二维表的形式存储数据。

非关系型数据库：

 - 存储数据的效率比较高；
 - 不是特别安全，突然断电时会导致数据丢失。

## 2. 关系型数据库
======

### 2.1 定义
----
关系型数据库，**是一种建立在关系模型（数学模型）上的数据库。**

至于关系模型，则是一种所谓建立在关系上的模型，其包含三个方面，分别为：

 - 数据结构：数据存储的形式，二维表（行和列）；
 - 操作指令集合：所有的 SQL 语句；
 - 完整性约束：表内数据约束（字段与字段）和表与表之间的约束（外键）。

### 2.2 设计
----

 - 数据库：从需要存储的数据需求中分析，如果是一类数据（实体），则应该设计成二维表；
 - 二维表：由表头（字段名，用来规定数据的名称）和数据（实际存储的内容）部分组成。

在此处，需要特别注意：**如果表中对应的某个字段值为空，但是系统依然会为其分配存储空间**，这也就是关系型数据库比较浪费空间的原因啦！

### 2.3 关键字说明
-------

 - DB：Database，数据库；
 - DBMS：Database Management System，数据库管理系统；
 - DBS：Database System = DBMS + DB，数据库系统；
 - DBA：Database Administrator，数据库管理员。
 - 行\记录：`row\record`，本质都是指表中的一行（一条记录），行是从结构角度出发，记录则是从数据角度出发。
 - 列\字段：`column\field`，本质都是指表中的一列（一个字段），列是从结构角度出发，字段则是从数据角度出发。

### 2.4 SQL
-----

SQL：Structured Query Language，结构化查询语言（数据以查询为主，99% 都是在进行查询操作）。

SQL 主要分为三种：

 - DDL：Data Definition Language，数据定义语言，用来维护存储数据的结构（数据库、表），代表指令为`create`、`drop`和`alter`等。
 - DML：Data Manipulation Language，数据操作语言，用来对数据进行操作（表中的内容）代表指令为`insert`、`delete`和`update`等，不过在 DML 内部又单独进行了一个分类，即 DQL（Data Query Language），数据查询语言，代表指令为`select`.
 - DCL：Data Control Language，数据控制语言，主要是负责（用户）权限管理，代表指令为`grant`和`revoke`等。

SQL 是关系型数据库的操作指令，是一种约束，但不强制，类似于 W3C，因此这意味着：不同的数据库产品（如 Oracle 和 MySQL）内部可能会有一些细微的区别。


## 3. MySQL 数据库


MySQL 数据库是一种`C\S`结构的软件，即分为：客户端和服务端。

若想访问服务器，则必须通过客户端；服务器应该一直运行，客户端则在需要使用的时候运行。

### 3.1 交互方式
----

 1. 客户端连接认证，即连接服务器，认证身份`mysql.exe -hPup`

	 - `-h`，主机地址，本地为`localhost`，远程为`IP`地址
	 - `-P`，端口号，用来找软件
	 - `-u`，用户名
	 - `-p`，密码
 
 2. 发送 SQL 指令；
 3. 服务器接受 SQL 指令，然后处理 SQL 指令并返回操作结果；
 4. 客户端接受结果并显示结果；
 5. 由于服务器并发限制，需要断开连接（三种指令，分别为：`exit`、`quit`和`\q`），释放资源。

### 3.2 服务器对象
-----
由于没办法完全了解服务器内部的结构，因此只能粗略的分析数据库服务器的内部结构。

一般来说，将 MySQL 数据库服务器的内部对象分为四层，分别为：数据管理系统（DBMS）--> 数据库（DB）--> 表（Table）--> 字段（Filed）.

## 4. SQL 基本操作

基本操作：CURD，即**增删改查**。

根据操作对象的不同，咱们可以将 SQL 的基本操作分为三类，分别为：库操作、表（字段）操作和数据操作。

### 4.1 库操作
---
### 4.1.1 新增数据库

基本语法：`create database + 数据库名称 + [库选项];`

其中，库选项是用来约束数据库的，为可选项（有默认值），共有两种，分别为：

 - 字符集设定：`charset/ character set`+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括`GBK`和`UTF8`等。
 - 校对集设定：`collate`+ 具体校对集，表示数据比较的规则，其依赖字符集。

示例：`create database TBL_ERROR_CODE charset utf8;`

其中，数据库的名字不能用关键字（已经被占用的字符，例如 update 和 insert 等）或者保留字（将来可能会用的，例如 access 和 cast 等）。

如果非要使用数据库的关键字或者保留字作为数据库名称，那么必须用反引号将其括起来，例如：

`create database `access` charset utf8;`

如果还想使用中文作为数据库的名称，那就得保证数据库能够识别中文（强烈建议不要用中文命名数据库的名称），例如：

```
-- 设置中文名称的方法，其中 gbk 为当前数据库的默认字符集
set names gbk;
create database 北京 charset gbk;
```

![](https://ws3.sinaimg.cn/large/006tNc79ly1ftt5gfua9sj309w02o0sw.jpg)

### 4.1.2 查询数据库

查看全部 --> 基本语法：`show databases;`

查看部分（模糊查询）--> 基本语法：`show databases like 'pattern';` 

其中，`pattern`是匹配模式，有两种，分别为：

 - `%`：表示匹配多个字符；
 - `_`：表示匹配单个字符。

此外，在匹配含有下划线`_`的数据库名称的时候，需要在下划线前面加上反斜线`\_`进行转义操作。

示例：`show databases like 'TBL%';`表示匹配所有`TBL`开头的数据库。

查看数据库的创建语句 --> 基本语法：`show create database + 数据库名称;`

在这里，查看的结果有可能与咱们书写的 SQL 语句不同，这是因为数据库在执行 SQL 语句之前会优化 SQL，系统保存的是优化后的结果。

### 4.1.3 更新数据库

在这里，需要注意：数据库的名字不可以修改。

数据库的修改仅限库选项，即字符集和校对集（校对集依赖字符集）。

基本语法：`alter database + 数据库名称 + [库选项];`

 - `charset/character set[=] 字符集;`
 - `collate[=] 校对集;`

示例：`alter database TBL_ERROR_CODE charset gbk;`表示修改此数据库的字符集为`gbk`.

### 4.1.4 删除数据库

基本语法：`drop database + 数据库名称;`

在这里，需要注意：在删除数据库之前，应该先进行备份操作，因为删除为不可逆操作，所以不要随意删除数据库。

## 5. 表操作
---

### 5.1 新增表

基本语法：
```
create table [if not exists] + 表名(
	字段名称 数据类型,
	……
	字段名称 数据类型	/* 最后后一行，不需要加逗号 */
)[表选项];
```

其中，`if not exists`表示

 - 如果表名不存在，就执行创建代码；如果表名存在，则不执行创建代码。

表选项则是用来控制表的表现形式的，共有三种，分别为：

 - 字符集设定：`charset/ character set`+ 具体字符集，用来表示数据存储的编码格式，常用的字符集包括`GBK`和`UTF8`等。
 - 校对集设定：`collate`+ 具体校对集，表示数据比较的规则，其依赖字符集。
 - 存储引擎：`engine`+具体存储引擎，默认为`InnoDB`，常用的还有`MyISAM`.

由于任何表都归属于某个数据库，因此在创建表的时候，都必须先指定具体的数据库。在这里，指定数据库的方式有两种，分别为：

 - **第 1 种**：显式的指定表所属的数据库，示例

```
create table if not exists test.student(
	name varchar(10),
	age int,            /* 整型不需要指定具体的长度 */
	grade varchar(10)	/* 最后后一行，不需要加逗号 */
)charset utf8;
```
 - **第 2 种**：隐式的指定表所属的数据库，示例

```
use test;				/* use + 数据库名称，表示切换到指定的数据库，这句命令其实不加分号也可以，但不建议这么做 */
create table if not exists student(
	name varchar(10),
	age int,            /* 整型不需要指定具体的长度 */
	grade varchar(10)	/* 最后后一行，不需要加逗号 */
)charset utf8;
```

### 5.2 查询表

查看全部 --> 基本语法：`show tables;`

查看部分（模糊查询）--> 基本语法：`show tables like 'pattern';` 

其中，`pattern`是匹配模式，有两种，分别为：

 - `%`：表示匹配多个字符；
 - `_`：表示匹配单个字符。

此外，在匹配含有下划线`_`的表名的时候，需要在下划线前面加上反斜线`\_`进行转义操作。

示例：`show tables like '%t';`表示匹配所有以`t`结尾的表。

查看表的创建语句 --> 基本语法：`show create table + 表名;`

在这里，咱们也可以用`\g`和`\G`代替上述语句中的`;`分号，其中`\g`等价于分号，`\G`则在等价于分号的同时，将查的表结构旋转`90`度，变成纵向结构。

查看表中的字段信息 --> 基本语法：`desc/describe/show columns from + 表名;`

### 5.3 更新表

在这里，需要注意：表的修改，分为修改表本身和修改表中的字段。

 - **第 1 类**：修改表本身
	 - 修改表名，基本语法：`rename table 旧表名 to 新表名;`
	 - 修改表选项，基本语法：`alter table + 表名 + 表选项[=] + 值;`

 - **第 2 类**：修改表中的字段，新增、修改、重命名和删除
	 - 新增字段，基本语法：`alter table + 表名 + add + [column] + 字段名 + 数据类型 + [列属性][位置];`
		 - 其中，位置表示此字段存储的位置，分为`first（第一个位置）`和`after + 字段名（指定的字段后，默认为最后一个位置）`.
		 - 示例：`alter table student add column id int first;`
	 - 修改字段，基本语法：`alter table + 表名 + modify + 字段名 + 数据类型 + [列属性][位置];`
		 - 其中，位置表示此字段存储的位置，分为`first（第一个位置）`和`after + 字段名（指定的字段后，默认为最后一个位置）`.
		 - 示例：`alter table student modify name char(10) after id;`
	 - 重命名字段，基本语法：`alter table + 表名 + change + 旧字段名 + 新字段名 + 数据类型 + [列属性][位置];`
		 - 其中，位置表示此字段存储的位置，分为`first（第一个位置）`和`after + 字段名（指定的字段后，默认为最后一个位置）`.
		 - 示例：`alter table student change grade class varchar(10);`
	 - 删除字段，基本语法：`alter table + 表名 + drop+ 字段名;`
		 - 示例：`alter table student drop age;`
		 - 注意：如果表中已经存在数据，那么删除该字段会清空该字段的所有数据，而且不可逆，慎用。

### 5.4 删除表

基本语法：

```
-- 可以一次删除多张表
drop table + 表1, 表2 ... ;	
```

在这里，需要注意：此删除为不可逆操作，希望大家谨慎使用。


## 6. 数据操作入门

---

### 6.1 新增数据

对于数据的新增操作，有两种方法。

 - **第 1 种**：给全表字段插入数据，不需要指定字段列表，但要求数据的值出现的顺序必须与表中的字段出现的顺序一致，并且凡是非数值数据，都需要用引号（建议使用单引号）括起来。
	 - 基本语法：`insert into + 表名 + values(值列表)[,(值列表)];`
	 - 示例：`insert into test valus('charies',18,'3.1');`
 - **第 2 种**：给部分字段插入数据，需要选定字段列表，字段列表中字段出现的顺序与表中字段的顺序无关，但值列表中字段值的顺序必须与字段列表中的顺序保持一致。
	 - 基本语法：`insert into + 表名(字段列表) + values(值列表)[,(值列表)];`
	 - 示例：`insert into test(age,name) valus(18,'guo');`


### 6.2 查询数据

查看全部 --> 基本语法：`select * from + 表名 + [where 条件];`

 - 示例：`select * from test`;

查看部分 --> 基本语法：`select + 字段名称[,字段名称] + from + 表名 + [where 条件];`

 - 示例：`select name,age,grade from test where age = '18'`;


### 6.3 更新数据

基本语法：`update + 表名 + set + 字段 = 值 + [where 条件];`

 - 示例：`update test set age = 20 where name = 'guo';`

在这里，建议尽量加上`where`条件，否则的话，操作的就是全表数据。

此外，判断更新操作是否成功，并不是看 SQL 语句是否执行成功，而是看是否有记录受到影响，即`affected`的数量大于`1`时，才是真正的更新成功。

### 6.4 删除数据

基本语法：`delete from + 表名 + [where 条件];`

 - 示例：`delete from test where grade = '3.1';`


当然，我们也可以用`drop`来实现删除操作，不过与`delete`相比，`drop`的威力更强，其在执行删除操作的时候，不仅会删除数据，还会删除定义并释放存储空间；而`delete`在执行删除操作的时候，仅会删除数据，并不会删除定义和释放存储空间。

----------



## 7. 常见问题-中文数据问题

**中文数据问题的本质就是字符集的问题。**

由于计算机仅识别二进制数据，而且人类则更倾向于识别字符（符号），因此就需要一个二进制与字符的对应关系，也就是**字符集**。

在咱们通过 MySQL 数据库的客户端向服务器插入中文数据的时候，有可能失败，原因则可能是客户端和服务器的字符集设置不同导致的，例如：

 - 客户端的字符集为`gbk`，则一个中文字符，对应两个字节；
 - 服务器的字符集为`utf8`，则一个中文字符，对应三个字节。

这样显然会在编码转换的过程中出现问题，从而导致插入中文数据失败。

由于所有的数据库服务器表现的一些特性都是通过服务器端的变量来保持的，因此系统会先读取自己的变量，看看具体的表现形式。这样的话，咱们就可以通过以下语句查看服务器到底识别哪些字符集：

```
-- 查看服务器识别的全部字符集
show character set;
```

![1](http://img.blog.csdn.net/20170505141901715)

通过以上查询，咱们会发现：**服务器是万能的，其支持所有字符集。**

既然服务器支持这么多字符集，总会有一种是服务器默认的和客户端打交道的字符集。因此，咱们可以通过以下语句查看服务器默认的对外处理的字符集：

```
-- 查看服务器默认的对外处理的字符集
show variables like 'character_set%'; 
```
![5](http://img.blog.csdn.net/20170505145310466)

 - 标注1：服务器默认的客户端传来的数据字符集为`utf8`；
 - 标注2：连接层字符集为`utf8`；
 - 标注3：当前数据库的字符集为`utf8`；
 - 标注4：服务器默认的对外处理的字符集`utf8`.

通过以上查询，咱们会发现：**服务器默认的对外处理的字符集是`utf8`**.

那么反过来，咱们在通过客户端的属性查看客户端支持的字符集：

![3](http://img.blog.csdn.net/20170505142119893)

显然，咱们已经找到了问题的根源，确实是：**客户端支持的字符集为`gbk`，而服务器默认的对外处理的字符集为`utf8`，因此产生矛盾。**

既然问题已经找到了，那么解决方案就是：**修改服务器默认接收的字符集为`gbk`**.

```
-- 修改服务器默认接收的字符集为 GBK（不区分大小写）
set character_set_client = gbk;
```

这样的话，咱们再插入中文数据的时候，就会插入成功啦！But，在咱们查看数据的时候，又发现了一个问题，就是之前咱们插入的中文数据显示乱码啦！不过这也正常，因为查询的时候，数据的来源是服务器（`utf8`），解析数据的是客户端，而客户端仅识别`gbk`格式的数据，显示乱码也就在意料之中啦！

因此，解决方案就是：**修改服务器给客户端的数据字符集为`gbk`**.

```
-- 修改服务器给客户端的数据字符集为 GBK（不区分大小写）
set character_set_results = gbk;
```

![4](http://img.blog.csdn.net/20170505143557398)

如上图所示，向服务器插入中文数据的问题已经解决啦！

----------
此外，咱们之前使用的 SQL 语句：

```
-- 修改的只是会话级别，即当前客户端当次连接有效，关闭后失效
set 变量 = 值;
```
这样的话，每当咱们重启客户端的时候，都要依次重新进行设置，比较麻烦，因此咱们可以使用快捷的设置方式，即：

```
set names 字符集;
```

例如，

```
/**
* 恒等于 set character_set_client = gbk;
* 恒等于 set character_set_results = gbk;
* 恒等于 set character_set_connection = gbk;
*/
set names gbk;
```

表示上述一条语句，将同时改变三个变量的值。其中，`connection`为连接层，是字符集转换的中间者，如果其和`client`和`results`的字符集一致，则效率更高，不一致也没有关系。


----------

## 8. 常见问题-校对集问题


**校对集，其实就是数据的比较方式。**

校对集，共有三种，分别为：

 - `_bin`：binary，二进制比较，区分大小写；
 - `_cs`：case sensitive，大小写敏感，区分大小写；
 - `_ci`：case insensitive，大小写不敏感，不区分大小写。

查看（全部）校对集 --> 基本语法：`show collation;`

![10](http://img.blog.csdn.net/20170505184606504)

如上图所示，MySQL 数据库支持百多种校对集。

接下来，咱们在一起看看校对集的应用，因为只有当数据进行比较的时候，校对集才会生效。在这里，咱们用`utf8`的`_bin`和`_ci`两种校对集进行比较：

```
-- 创建两张使用不同校对集的表
create table my_collate_bin(
	name char(10)
)charset utf8 collate utf8_bin;

create table my_collate_ci(
	name char(10)
)charset utf8 collate utf8_general_ci;

```

![11](http://img.blog.csdn.net/20170505185330045)

如上图所示，咱们创建了两张表，分别为`my_collate_bin`和`my_collate_ci`，其校对集分别为`_bin`和`_ci`. 然后，分别向这两张表中添加数据：

```
-- 向表中添加数据
insert into my_collate_bin values ('a'),('A'),('B'),('b');
insert into my_collate_ci values ('a'),('A'),('B'),('b');
```

再分别查看两张表中的数据：

```
-- 查看表中的数据
select * from my_collate_bin;
select * from my_collate_ci;
```
![13](http://img.blog.csdn.net/20170505190118166)

下面，咱们根据表中的某个字段（在这里`my_collate_bin`和`my_collate_ci`都仅有一个字段）进行排序，其基本语法为：

```
order by + 字段名 + [asc/desc];
```
其中，`asc`表示升序，`desc`表示降序，默认为升序。执行如下 SQL 语句：

```
-- 排序比较
select * from my_collate_bin order by name;
select * from my_collate_ci order by name;
```

![14](http://img.blog.csdn.net/20170505190700955)

如上图所示，显然校对集生效啦！

此外，咱们需要特别注意的是：	**校对集必须在没有数据之前声明好，如果有了数据之后，再进行校对集的修改，则修改无效。**

----------


## 9. 列类型（数据类型）

所谓的列类型，其实就是指数据类型，即对数据进行统一的分类，从系统的角度出发是为了能够使用统一的方式进行管理，更好的利用有限的空间。

在 SQL 中，将数据类型分成了三大类，分别为：**数值型、字符串型和日期时间型。**

![1](http://img.blog.csdn.net/20170505201016682)

对于数值型数据，可以进一步将其划分为**整数型**和**小数型**。

### 9.1 整数型
---

在 SQL 中，由于要考虑节省磁盘空间的问题，因此系统又将整型细分成五类，分别为：

 - `tinyint`：迷你整型，使用 1 个字节存储数据（常用）；
 - `smallint`：小整型，使用 2 个字节存储数据；
 - `mediumint`：中整型，使用 3 个字节存储数据；
 - `int`：标准整型，使用 4 个字节存储数据（常用）；
 - `bigint`：大整型，使用 8 个字节存储数据。

接下来，输入如下 SQL 语句进行测试：

```
-- 创建整型表
create table my_int(
	int_1 tinyint,
	int_2 smallint,
	int_3 int,
	int_4 bigint
)charset utf8;
```

![2](http://img.blog.csdn.net/20170505214100825)

如上图所示，咱们已经成功创建`my_int`表，再插入数据：

```
-- 插入数据
insert into my_int values (1,2,3,4);
insert into my_int values ('a','b','c','d');
insert into my_int values (255,2,3,4);
```

![3](http://img.blog.csdn.net/20170505214735859)

如上图所示，通过列类型，咱们可以限定插入数据的类型以及长度范围。

至于为什么在对`int_1`赋值时，报出超出范围的错误，则是因为在 SQL 中数值类型默认是有符号位的，即分正负。如果需要使用无符号的数据，这就需要咱们自己对数据类型进行声明啦，即在声明数据类型时，追加`unsigned`关键字。例如：

```
-- 在 my_int 表中，添加 int_5 字段，设置其数据类型为 tinyint unsigned
alter table my_int add int_5 tinyint unsigned;
```
![4](http://img.blog.csdn.net/20170505215530129)

如上图所示，添加`int_5`字段成功，继续插入数据：

```
-- 插入数据
insert into my_int values (1,2,3,4,255);
```

![5](http://img.blog.csdn.net/20170505215905568)

如上图所示，当咱们将`tinyint`限定为`unsigned`之后，已经可以插入`0~255`之间的任何整数啦！但是，回过头来，让咱们仔细看看下面这张图：

![6](http://img.blog.csdn.net/20170505220452057)

通过观察上面这张图，咱们会发现：**每个字段的数据类型后面都会跟着一对括号，并且里面含有数字。**这些数字啊，其实并没有什么特别的含义，只是表示数据的显示宽度。实际上，咱们可以修改显示的宽度，但是这种修改并不会改变数据本身的大小。

**显示宽度的意义**：在于当数据不够显示宽度的时候，会自动让数据变成对应的显示宽度，通常需要搭配一个前导`0`来增加宽度，其不改变数据值的大小，即用`zerofill`进行零填充，并且零填充会导致数值自动变成无符号。

下面，执行如下 SQL 语句：

```
-- 在 my_int 表中，添加 int_6 字段，设置其数据类型为 tinyint zerofill
alter table my_int add int_6(3) tinyint zerofill;
```

![7](http://img.blog.csdn.net/20170505221652339)

再插入数据，进行测试：

```
-- 插入数据
insert into my_int values (1,2,3,4,5,6);
```

![8](http://img.blog.csdn.net/20170505222047969)

如上图所示，**零填充的意义**：在于保证数据的格式。

### 9.2 小数型
---
小数型，即**带有小数点或者范围超出整型的数值类型**。

在 SQL 中，将小数型细分为**浮点型**和**定点型**两种，其中：

 - 浮点型：小数点浮动，精度有限，容易丢失精度；
 - 定点型：小数点固定，精度固定，不会丢失精度。

**第 1 种**：浮点型

浮点型数据是一种精度型数据，因为超出指定范围之后，其会丢失精度，自动进行四舍五入操作。理论上，浮点型分为两种精度：

 - `float`：单精度，占用 4 个字节存储数据，精度范围大概为 7 位左右；
 - `double`：双精度，占用 8 个字节存储数据，精度范围大概为 15 位左右。

**浮点型的使用方式**：如果直接用`float`，则表示没有小数部分；如果用`float(M,D)`，其中`M`代表总长度，`D`代表小数部分长度，`M-D`则为整数部分长度。

执行如下 SQL 语句创建浮点数表，进行测试：

```
-- 创建浮点数表
create table my_float(
	f1 float,
	f2 float(10,2),
	f3 float(6,2)
)charset utf8;
```
在咱们向浮点数表`my_float`插入数据的时候，可以直接插入小数，也可以插入用科学计数法表示的数据。此外，插入浮点型数据时，整数部分是不能超出长度范围的，但是小数部分是可以超出长度范围的，系统会自动进行四舍五入的操作。特别是，如果浮点数是因为系统进位（四舍五入）导致整数部分超出指定的长度，那么系统是允许成立的。

```
-- 插入测试数据
insert into my_float values (2.15e4,20.15,9999.99);
insert into my_float values (20151120,123456789.99,9999.99);
insert into my_float values (5211314,123456.99,99.99999);
```

![1](http://img.blog.csdn.net/20170506102816519)

如上图所示，咱们的结论得到了验证。

**第 2 种**：定点型

定点型数据，绝对的保证整数部分不会被四舍五入，也就是说不会丢失精度，但小数部分有可能丢失精度，虽然理论上小数部分也不会丢失精度。

执行如下 SQL 语句创建定点数表，以浮点数做对比，进行测试：

```
-- 创建定点数表
create table my_decimal(
	f1 float(10,2),
	d1 decimal(10,2)
)charset utf8;
```
当咱们插入数据的时候，定点数的整数部分一定不能超出长度范围（进位也不可以），小数部分的长度则可以随意超出，没有限制，系统会自动进行四舍五入的操作：

```
-- 插入测试数据
insert into my_decimal values (99999999.99,99999999.99);
insert into my_decimal values (123456789.99,2015.1314);
insert into my_decimal values (123456.99,2015.1314);
```

![2](http://img.blog.csdn.net/20170506105942273)

如上图所示，咱们的结论同样得到了验证。

### 9.3 日期时间型
---

日期时间型数据，顾名思义，就是用来表示日期和时间的数据类型，共有五种类型，分别为：

 - `datetime`：日期时间，其格式为`yyyy-MM-dd HH:mm:ss`，表示的范围是从 1000 年到 9999 年，有零值，即`0000-00-00 0000:00`；
 - `date`：日期，就是`datetime`的`date`部分；
 - `time`：时间，或者说是时间段，为指定的某个时间区间之间，包含正负时间；
 - `timestamp`：时间戳，但并不是真正意义上的时间戳，其是从`1970`年开始计算的，格式和`datetime`一致；
 - `year`：年份，共有两种格式，分别为`year(2)`和`year(4)`.

执行如下 SQL 语句创建日期时间表，进行测试：

```
-- 创建日期时间表
create table my_date(
	d1 datetime,
	d2 date,
	d3 time,
	d4 timestamp,
	d5 year
)charset utf8;
```

当咱们插入数据时，日期时间型中的`time`，可以为负数，甚至可以是很大的负数；`year`，可以使用 2 位数据插入，也可以使用 4 位数据插入；`timestamp`，只要当前所在的记录被更新，该字段就会自动更新为当前时间，且**时间戳类型默认为非空的**。

```
-- 插入测试数据
insert into my_date values ('2017-05-06 13:15:00','2017-05-06','13:15:00','2017-05-06 13:15:00',2017);
insert into my_date values ('2017-05-06 13:15:00','2017-05-06','-113:15:00','2017-05-06 13:15:00',69);
insert into my_date values ('2017-05-06 13:15:00','2017-05-06','-2 13:15:00','2017-05-06 13:15:00',70);
```

![3](http://img.blog.csdn.net/20170506132014635)

如上图所示，以上 3 条记录已经插入成功，接下来，咱们再来验证更新记录时，时间戳类型的字段`d4`是否会自动更新：

```
-- 更新记录，验证时间戳类型的字段是否会自动更新
update my_date set d1 = '2017-05-06 13:24:00' where d5 = 1970;
```

![5](http://img.blog.csdn.net/20170506132904083)

如上图所示，显然咱们的结论全部得到了验证。


### 9.4 字符串型
---

在 SQL 中，将字符串类型分成了 6 类，分别为：`char`、`varchar`、`text`、`blob`、`enum`和`set`.

**第 1 类：定长字符串**

定长字符串：`char`，即磁盘（二维表）在定义结构的时候就已经确定了最终数据的存储长度。

 - `char(L)`：L 表示 Length，即可以存储的长度，单位为字符，最大长度为 255；
 - `char(4)`：表示在 UTF8 环境下，需要 4*3=12 个字节。

**第 2 类：变长字符串**

变长字符串：`varchar`，即在分配存储空间的时候，按照最大的空间分配，但是实际用了多少，则是根据具体的数据来确定。

 - `varchar(L)`：L 表示 Length，理论长度是 65536，但是会多出 1 到 2 个字节来确定存储的实际长度；
 - `varchar(10)`：例如存储 10 个汉字，在 UTF8 环境下，需要 10*3+1=31 个字节。

实际上，如果存储长度超过 255 个字符，则既不用定长字符串也不用变长字符串，而是用文本字符串`text`.

如何选择定长字符串或者是变长字符串呢？

 - 定长字符串对磁盘空间比较浪费，但是效率高：如果数据基本上确定长度都一样，就使用定长字符串，例如身份证、电话号码等；
 - 变长字符串对磁盘空间比较节省，但是效率低：如果数据不能确定长度（不同的数据有变化），就使用变长字符串，例如地址、姓名等。

**第 3 类：文本字符串**

如果数据量非常大，通常说超过 255 个字符就会使用文本字符串。

文本字符串根据存储的格式进行分类，可以分为：

 - `text`：存储文字；
 - `blob`：存储二进制数据（其实际上都是存储路径），通常不用。

**第 4 类：枚举字符串**

枚举字符串：`enum`，需要事先将所有可能出现的结果都设计好，实际上存储的数据必须是规定好的数据中的一个。

枚举字符串的使用方式：

 - 定义：`enum('元素1','元素2','元素3'...)`，例如`enum('男','女','保密')`；
 - 使用：存储的数据，只能是事先定义好的数据。

执行如下 SQL 语句创建枚举表，进行测试：

```
-- 创建枚举表
create table my_enum(
	gender enum('男','女','保密')
)charset utf8;
```

![2](http://img.blog.csdn.net/20170521214843424)

再执行如下 SQL 语句，向表`my_enum`中插入测试数据：

```
-- 插入测试数据
insert into my_enum values ('男'),('女'),('保密');
insert into my_enum values ('male');
```
![3](http://img.blog.csdn.net/20170521215211842)

通过上面的测试，咱们可以发现使用枚举字符串有一个好处，那就是：**规范数据格式，插入表中的数据只能是事先定义好的某个数据。**

此外，枚举字符串还有一个作用，那就是：**节省存储空间（枚举数据通常都有一个别名），枚举实际上存储的是数值而不是字符串本身。**

在 MySQL 中，系统是有自动转换数据格式的功能的。在这里，咱们可以证明枚举字段存储的是数值，具体方法为：将数据取出来`+0`，如果是字符串最终结果永远为`0`，否则就是其他值。

```
-- 验证枚举字段实际存储的格式
select gender + 0,gender from my_enum;
```

![4](http://img.blog.csdn.net/20170521220113393)

观察上述结果，咱们可以找出枚举元素的实际规律，即按照元素出现的顺序，从`1`开始编号。接下来，咱们再来了解**枚举的原理**：

 - 枚举在进行数据规范（定义）的时候，系统会自动建立一个数字与枚举元素的对应关系（放在日志中）；在进行数据插入的时候，系统自动将字符串转换为对应的数值进行存储；在进行数据提取的时候，系统自动将数值转换成对应的字符串进行显示。

通过阅读以上枚举的原理，咱们可以知道：**使用枚举的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。**

**第 5 类：集合字符串**

集合字符串：`set`，跟枚举类似，实际存储的是数值而不是字符串。

集合字符串的使用方式：

 - 定义：`set`，元素列表；
 - 使用：可以使用元素列表中的多个元素，用逗号分隔。

执行如下 SQL 语句创建枚举表，进行测试：

```
-- 创建集合表
create table my_set(
	hobby set('音乐','电影','旅行','美食','摄影','运动','宠物')
)charset utf8;
```

![5](http://img.blog.csdn.net/20170521223557192)

再执行如下 SQL 语句，向表`my_set`中插入测试数据：
```
-- 插入测试数据
insert into my_set values ('电影,美食,宠物');
insert into my_set values (3);
```

![6](http://img.blog.csdn.net/20170521223912147)

再执行如下 SQL 语句，查看表`my_set`中的数据：

```
-- 查看数据
select hobby + 0,hobby from my_set;
```

![7](http://img.blog.csdn.net/20170521224106226)

观察上面的结果，相信大部分童鞋也懵啦！对于`3`还好理解，`3=2+1`，对应于集合中数据的编号，也正是`音乐`和`电影`；但是`74`是什么鬼啊？在此，咱们不妨将集合（`'音乐','电影','旅行','美食','摄影','运动','宠物'`）中的元素选中的记为`1`，没有选中的记为`0`，表示成二进制，也就是：

 - `0101001`

再将上面的二进制反过来：

 - `1001010`

不妨算算，上述二进制对应的十进制数，即为`74`.

到这里，相信大家已经恍然大悟啦，原来：**集合字符串中每一个元素都对应一个二进制位，其中被选中的为`1`，未选中的为`0`，最后在反过来，这个二进制数对应的十进制数即为其数据库中实际存储的是数值。**

此外，集合字符串中插入元素的顺序并没有影响，最终系统都会自动去匹配集合的顺序，即：

```
-- 插入测试数据
insert into my_set values ('电影,美食,旅行');
insert into my_set values ('旅行,电影,美食');
```

上述两个 SQL 语句会产生相同的结果：

![8](http://img.blog.csdn.net/20170521230456356)

如上图所示，显然咱们的结论得到了验证。

最后，集合的原理同枚举类似，因此可以的到相同的结论，即：**使用集合的效率并不高（低于其他类型的数据），但能规范数据和节省存储空间。**

----------

##  10. 记录长度

MySQL 中规定：**任何一条记录最长不超过 65535 个字节，这意味着`varchar`永远达不到理论最大值**。

那么，`varchar`实际存储长度能达到多大呢？这由编码字符集决定。

下面，以`varchar`在`UTF-8`和`GBK`的情况为例，执行如下 SQL 语句，进行演示：

```
-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值
create table my_utf8(
	name varchar(65535)
)charset utf8;

create table my_gbk(
	name varchar(65535)
)charset gbk;
```

![1](http://img.blog.csdn.net/20170522161909823)

观察上面的结果，发现咱们定义的字段`name`的长度超过限制啦，并且提示了其在`utf8`和`gbk`字符集下各自的最大值。那么，咱们修改 SQL 语句如下，并再次执行：

```
-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值
create table my_utf8(
	name varchar(21845)
)charset utf8;

create table my_gbk(
	name varchar(32767)
)charset gbk;
```

![2](http://img.blog.csdn.net/20170522162320934)

观察上面的执行结果，好吧，仍然在报错，为什么呢？观察如下 SQL 语句，并执行：

```
-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值
create table my_utf8(
	name varchar(21844)  -- 21844 * 3 + 2 = 65534
)charset utf8;

create table my_gbk(
	name varchar(32766)  -- 32766 * 2 + 2 = 65534
)charset gbk;
```

![3](http://img.blog.csdn.net/20170522163928644)

如上图所示，咱们已经创建成功啦！至于什么定义字段`name`的长度为`21844`和`32766`是由于：

 - `21845 * 3 + 2 = 65537 > 65535`
 - `32767 * 2 + 2 = 65536 > 65535`

因此，在提示的最大值的基础上各自减`1`. 至于，为什么还要加`2`，则是因为`varchar`为变长字符串，在其定义的时候，也就是说在分配存储空间的时候，都会自动多分配`1`到`2`个字节空间，因为咱们想要算最大的存储范围，所以加`2`.

在这里，细心的同学会发现一个问题，那就是：在咱们创建表`my_utf8`和`my_gbk`的时候，咱们仅用了`65534`个字节，还剩余一个字节。现在，如果咱们想要将`65535`个字节都用了，怎么办呢？好说，增加一个`tinyint`类型的字段即可：

```
-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值
create table my_utf81(
	stuno tinyint,       -- 1
	name varchar(21844)  -- 21844 * 3 + 2 = 65534
)charset utf8;

create table my_gbk1(
	stuno tinyint,       -- 1
	name varchar(32766)  -- 32766 * 2 + 2 = 65534
)charset gbk;
```

![4](http://img.blog.csdn.net/20170522165051589)

观察上面的结果，呃，竟然又出错啦！为什么啊？`65534 + 1 = 65535`，并没有超出范围啊！其实吧，之所以会出现这样的问题，是因为：**在 MySQL 的记录中，如果有任何一个字段允许为空，那么系统就会自动从整个记录中保留一个字节来存储`null`，若想释放`null`所占的字节，则必须保证所有字段都不允许为空。**

```
-- 求出 varchar 在 utf8 和 gbk 字符集下的实际最大值
create table my_utf82(
	stuno tinyint not null,       -- 1
	name varchar(21844) not null  -- 21844 * 3 + 2 = 65534
)charset utf8;

create table my_gbk2(
	stuno tinyint not null,       -- 1
	name varchar(32766) not null  -- 32766 * 2 + 2 = 65534
)charset gbk;
```

![5](http://img.blog.csdn.net/20170522165703155)

如上图所示，咱们已经成功创建了表`my_utf82`和`my_gbk2`. 

此外，在 MySQL 中，`text`文本字符串不占用记录长度，额外存储，但是`text`文本字符串也是属于记录的一部分，无论是在`utf8`还是在`gbk`字符集之中，其都占用记录中的`10`个字节长度，用来保存数据的地址以及长度。

----------

## 11. 列属性

列属性：实际上，**真正约束字段的是数据类型，但是数据类型的约束比较单一，因此就需要额外的一些约束来保证数据的有效性，这就是列属性。**

列属性有很多，例如：`null`、`not null`、`default`、`primary key`、`unique key`、`auto_increment`和`comment`等。

### 11.1 空属性

空属性有两个值，分别为：`null`和`not null`.

虽然默认数据库的字段基本都为空，但是**实际上在真正开发的时候，要尽可能的保证数据不为空，因为空数据没有意义，也没办法参与运算**。

执行如下 SQL 语句，进行演示：

```
-- 空属性演示
create table my_class(
	grade varchar(20) not null,
	room varchar(20) null  -- 显式声明为空，实际上，默认就为空
)charset utf8;
```

![6](http://img.blog.csdn.net/20170523102924169)

### 11.2 列描述

列描述：`comment`，表示描述，没有实际含义，**是专门用来描述字段的，其会随着表创建语句自动保存，用来给程序员（数据库管理员）了解数据库使用。**

执行如下 SQL 语句，进行演示：

```
-- 列描述演示
create table my_friend(
	name varchar(20) not null comment '姓名',
	age tinyint not null comment '年龄'
)charset utf8;
```
![8](http://img.blog.csdn.net/20170523120146063)

### 11.3 默认值

默认值：`default`，**某一数据会经常性出现某个具体的值，因此可以在开始的时候就指定好，而在需要真实数据的时候，用户可以选择性的使用默认值。**

执行如下 SQL 语句，进行演示：

```
-- 默认值演示
create table my_default(
	name varchar(20) not null,
	age tinyint unsigned default 0,
	gender enum('男','女') default '男'
)charset utf8;
```

![9](http://img.blog.csdn.net/20170523120331562)

如上图所示，在列属性`Default`中已经展示了`age`和`gender`字段的默认值，这说明咱们设置成功啦！接下来，咱们再演示如何使用默认值：

```
-- 演示默认值的使用（即不该对应的字段赋值）
insert into my_default (name) values ('Charies');
insert into my_default values ('Guo',18,default);
```

![10](http://img.blog.csdn.net/20170523121027497)

观察上面的 SQL 语句及执行结果，相信大家已经知道如何使用默认值啦，即不给设置默认值的字段赋值或者用`default`代替相应的字段值。

----------

## 12. 主键

主键：`primary key`，**表中主要的键，每张表只能有一个字段（复合主键，可以多个字段）使用此属性，用来唯一的约束该字段里面的数据，不能重复**。

### 12.1 增加主键

在 SQL 操作中，有 3 种方法可以给表增加主键，分别为：

**第 1 种**：在创建表的时候，直接在字段之后，添加`primary key`关键字

```
-- 增加主键
create table my_pri1(
	name varchar(20) not null comment '姓名',
	number char(10) primary key comment '学号'
)charset utf8;
```
![1](http://img.blog.csdn.net/20170523210307014)

如上图所示，此方法的优点是清晰明了，缺点则是只能使用一个字段作为主键。

**第 2 种**：在创建表的时候，在所有的字段之后，使用`primary key(主键字段列表)`来创建主键（如果有多个字段作为主键，则称之为复合主键）

```
-- 复合主键
create table my_pri2(
	number char(10) not null comment '学号',
	course char(10) not null comment '课程编号',
	score tinyint unsigned default 60,
	-- 增加主键限制，学号和课程编号应该是对应的，具有唯一性
	primary key(number,course)
)charset utf8;
```

![2](http://img.blog.csdn.net/20170523211344326)

**第 3 种**：当表创建完之后，额外追加主键，可以直接追加主键，也可以通过修改表字段的属性追加主键

```
-- 追加主键
create table my_pri3(
	course char(10) not null comment '课程编号',
	name varchar(10) not null comment '课程名称'
)charset utf8;
```
![3](http://img.blog.csdn.net/20170523211827926)

在这里，追加主键有两种方式，分别为：

- `alter table my_pri3 modify course char(10) primary key comment '课程编号';  -- 不建议使用`

- `alter table my_pri3 add primary key(course);  -- 推荐使用`

![4](http://img.blog.csdn.net/20170523212240672)

如上图所示，咱们追加主键成功。不过，想要用此方法，有一个前提，那就是：**表中对应字段的数据是不重复的，即保证唯一性**。

### 12.2 主键约束

主键约束，即**主键对应的字符中的数据不允许重复，如果重复，则数据操作（主要是增和改）失败**。

```
-- 主键约束（冲突）测试
insert into my_pri3 values('MATH00123','泛函分析');
insert into my_pri3 values('MATH00123','非线性分析');
```

![5](http://img.blog.csdn.net/20170523213342164)

### 12.3 更新主键 & 删除主键

对于主键，没有办法直接更新，主键必须先删除，然后才能更新。

 - 基本语法：`alter table + 表名 + drop primary key;`

执行如下 SQL 语句，进行测试：
```
-- 删除主键
alter table my_pri3 drop primary key;
```
![6](http://img.blog.csdn.net/20170523214019191)

如上图所示，咱们已经成功删除表`my_pri3`的主键啦！想要增加主键，只需要通过前面讲的 3 种方法即可。

### 12.4 主键分类

根据主键的字段类型，咱们可以将主键分为两类，分别为：

 - 业务主键，即使用真实的业务数据作为主键，例如学号、课程编号等等，很少使用；
 - 逻辑主键，即使用逻辑性的字段作为主键，字段没有业务含义，值有没有都没有关系，经常使用。

至此，咱们已经将主键的相关内容讲完啦！

----------

## 13. 自动增长

自动增长：`auto_increment`，**当对应的字段，不给值，或者是默认值，或者是`null`的时候，就会自动的被系统触发，系统会从当前字段中取已有的最大值再进行`+1`操作，得到新的字段值**。

自增长通过跟主键进行搭配使用，其特点为：

 - 任何字段要做自增长，前提其本身必须是一个索引，即`key`栏有值；
 - 自增长字段必须是数字（整型）；
 - 每张表最多有一个自增长字段。

执行如下 SQL 语句，进行测试：

```
-- 自增长示例
create table my_auto(
	id int primary key auto_increment,
	name varchar(20) not null
)charset utf8;
```

![1](http://img.blog.csdn.net/20170523225451048)

### 13.1 使用自增长

当自增长给定的值为`null`或者默认值的时候，就是触发自动增长。

```
-- 触发自增长
insert into my_auto (name) values('Charies');
insert into my_auto values(null,'Guo');
insert into my_auto values(default,'ChariesGuo');
```
![2](http://img.blog.csdn.net/20170523230214445)

如上图所示，自增长的第一个元素默认是`1`，自增长每次都是自增`1`。此外，如果自增长对应的字段输入了值，那么自增长失效，但是下一次还是能够正确的自增长，即从取该字段的最大值`+1`.

那么，如何确定下一次自增长的数值是什么呢？简单，咱们可以通过查看表的创建语句看到。

```
-- 查看表的创建语句
show create table my_auto;
```
![3](http://img.blog.csdn.net/20170523230908501)

如上图所示，显然在咱们之前插入的 3 条记录之后，下一次自增长是`4`，符合咱们的结论。

### 13.2 修改自增长

自增长如果是涉及到字段改变，就必须先删除自增长，然后再增加自增长，因为每张表只能有一个自增长字段。

如果修改当前自增长字段已经存在的值，则只能修改比当前已有自增长字段中的最大值更大，不能更小，因为更小不生效。

 - 基本语法：`alter table + 表名 + auto_increment = 值;`

执行如下 SQL 语句，进行测试：

```
-- 修改自增长测试
alter table my_auto auto_increment = 2;
```

![4](http://img.blog.csdn.net/20170523233034847)

如上图所示，当咱们修改自增长小于当前自增长字段中的最大值时，虽然显示 SQL 语句执行成功，但实际上并没有修改成功。下面，在执行如下 SQL 语句，进行测试：

```
-- 修改自增长测试
alter table my_auto auto_increment = 5;
```

![5](http://img.blog.csdn.net/20170523233250704)

如上图所示，显然当咱们修改自增长大于当前自增长字段中的最大值时，修改成功。

在这里，咱们不妨思考一下，为什么自增长是从`1`开始呢？为什么每次都自增`1`呢？虽然现在咱们不知道是什么原因导致上面的表示形式，但是咱们知道，所有系统的表现（如字符集、校对集）都是由系统内部的变量进行控制的，因此咱们可以查看自增长对应的变量：

 - 基本语法：`show variables like 'auto_increment%';`

```
-- 查看自增长变量
show variables like 'auto_increment%';
```
![6](http://img.blog.csdn.net/20170523234155133)

如上图所示，其中`auto_increment_increment`表示`步长`，`auto_increment_offset`表示`初始值`.

因此，咱们可以通过修改上面的两个变量实现不同的效果，但是需要注意的是：**修改是会话级别，并且修改的是整个数据库，而不是单张表。**

 - 基本语法：`set auto_increment_increment = 值;`

执行如下 SQL 语句，进行测试：

```
-- 修改自增长步长
set auto_increment_increment = 5;
insert into my_auto values (null,'Guobinhit');
```
![7](http://img.blog.csdn.net/20170523234752168)

如上图所示，咱们已经修改成功！接下来，执行如下 SQL 语句，进行测试：
```
-- 插入测试数据
insert into my_auto values (null,'Guobinhit');
insert into my_auto values (default,'Guobinhit');
```

![8](http://img.blog.csdn.net/20170523235047044)

如上图所示，咱们插入的第一个`Guobinhit`的`id`值竟然是`6`，第二个`Guobinhit`的`id`值倒是在`6`的基础上增加了`5`为`11`正常。这个现象产生的原因是：咱们之前的修改会导致系统产生一个误差，从初始值`1`开始计算加`5`，因此第一个`Guobinhit`的`id`值是`6`. 

不过说实话，修改自增长并没有什么实际的意义，在此只是想让大家知道：自增长的初始值和步长都是可以修改的而已。

### 13.3 删除自增长

自增长是字段的一个属性，因此可以通过`modify`来进行修改。想要删除自增长的话，**只需要保证字段没有`auto_increment`即可**。

 - 基本语法：`alter table + 表名 + modify + 字段 + 类型;`

执行如下 SQL 语句，进行测试：

```
-- 删除自增长
alter table my_auto modify id int primary key;
```
![9](http://img.blog.csdn.net/20170524000518389)

如上图所示，呃，好吧，出错啦！这是因为表`my_auto`之前已经定义了主键，所以在执行上述 SQL 语句的时候，系统会认为咱们想要定义多个主键，自然就要报错啦！解决方法就是，去掉上述 SQL 语句中的`primary key`即可。

![10](http://img.blog.csdn.net/20170524000826628)

如上图所示，显然咱们已经成功删除自增长啦！

----------


## 14. 唯一键

唯一键：每张表往往有多个字段需要具有唯一性，数据不能重复，但是在每张表中，只能有一个主键，因此**唯一键就是用来解决表中多个字段需要具有唯一性的问题**。

唯一键的本质与主键差不多，唯一键默认的允许字段为空，而且可以多个字段为空，因此空字段不参与唯一性的比较。

### 14.1 增加唯一键

增加唯一键的方法和主键类似，有 3 种方法，分别为：

**第一种**：在创建表的时候，字段后面直接添加`unique`或者`unique key`关键字

```
-- 增加唯一键
create table my_unique(
	number char(10) unique comment '学号',
	name varchar(20) not null
)charset utf8;
```
![1](http://img.blog.csdn.net/20170524090620434)

**第 2 种**：在所有字段之后，增加`unique key(字段列表)`，可以设置复合唯一键

```
-- 测试唯一键
create table my_unique2(
	number char(10) not null,
	name varchar(20) not null,
	unique key(number)	
)charset utf8;
```
![2](http://img.blog.csdn.net/20170524091144437)

观察上图，咱们可能会发现一个问题，那就是：**咱们设置的唯一键`UNI`，怎么变成了主键`PRI`啊？这是由于当唯一键满足非空条件的时候，其性质就和主键一样啦，因此在表中显示为`PRI`**. 当然，在咱们执行如下 SQL 语句的时候，其就会表现出真正的性质：

```
-- 查看表创建语句
show create table my_unique2;
```
![3](http://img.blog.csdn.net/20170524091651347)

**第 3 种**：在创建表之后，增加唯一键

```
-- 创建未设置唯一键的表
create table my_unique3(
	id int primary key auto_increment,
	number char(10) not null,
	name varchar(20) not null
)charset utf8;
```

![4](http://img.blog.csdn.net/20170524092040004)

如上图所示，表`my_unique3`未设置唯一键。接下来，执行如下 SQL 语句，进行测试：

```
-- 增加唯一键
alter table my_unique3 add unique key(number);
```
![5](http://img.blog.csdn.net/20170524092306849)

如上图所示，咱们已经成功向表中增加唯一键啦！

### 14.2 唯一键约束

唯一键与主键本质相同，区别在于：**唯一键允许字段值为空，并且允许多个空值存在**。

```
-- 测试唯一键约束
insert into my_unique values(null,'Charies');
insert into my_unique values(null,'Guo');
```
![6](http://img.blog.csdn.net/20170524093013603)

### 14.3 更新唯一键 & 删除唯一键

在表中，更新唯一键的时候，可以不用先删除唯一键，因为表的唯一键允许有多个。

删除唯一键的语法为：

 - 基本语法：`alter table + 表名 + drop index + 索引名字;`

在这里，唯一键默认使用字段名作为索引名。

```
-- 删除唯一键
alter table my_unique3 drop index number;
```
![7](http://img.blog.csdn.net/20170524093806457)

如上图所示，显然咱们已经成功删除表中的唯一键啦！


----------

## 15. 索引

索引：**系统根据某种算法，将已有的数据（未来可能新增的数据），单独建立一个文件，这个文件能够实现快速匹配数据，并且能够快速的找到对应的记录**，几乎所有的索引都是建立在字段之上的。

索引的意义：

 - 提升查询数据的效率；
 - 约束数据的有效性。

但是增加索引是有前提条件的，这是因为索引本身会产生索引文件（有的时候可能会比数据本身都大），因此非常耗费磁盘空间。

 - 如果某个字段需要作为查询的条件经常使用，可以使用索引；
 - 如果某个字段需要进行数据的有效性约束，也可以使用索引（主键或唯一键）。

MySQL 中提供了多种索引，包括：

 1. 主键索引`primary key`
 2. 唯一键索引`unique key`
 3. 全文索引`fulltext index`
 4. 普通索引`index`

其中，主键和唯一键咱们之前已经了解过啦！至于普通索引，顾名思义，并没有什么特色，唯一的任务就是加快数据的查询速度。

在这里，咱们说说全文索引。全文索引，即根据文章内部的关键字进行索引，其最大的难度就是在于如何确定关键字。对于英文来说，全文索引的建立相对容易，因为英文的两个单词之间有空格；但是对于中文来说，全文索引的建立就比较难啦，因为中文两个字之间不仅没有空格，而是还可以随意组合。


----------

## 16. 关系

在数据库中，将实体与实体的关系反应到表的设计上来，可以细分为 3 种，分别为：一对一`(1:1)`，一对多`(1:N)`（或多对一`(N:1)`）和多对多`(N:N)`。

在此，所有的关系都是指表与表之间的关系。

### 16.1 一对一

一对一，即**一张表的一条记录只能与另外一张表的一条记录相对应，反之亦然**。

例如，咱们设计一张「个人信息表」，其字段包含：姓名、性别、年龄、身高、体重、籍贯和居住地等。

![0](http://img.blog.csdn.net/20170601085452637)

如上表所示，基本满足咱们的要求，其中姓名、性别和年龄属于常用数据，但是身高、体重、籍贯和居住地为不常用数据。如果每次查询都要查询所有数据的话，那么不常用数据就会影响效率，而且又不常用。因此，咱们可以将常用的数据和不常用的数据分离存储，即分为两张表，例如：

**表 1：常用数据**

![1](http://img.blog.csdn.net/20170601085511060)

**表 2：不常用数据**

![2](http://img.blog.csdn.net/20170601085527435)

如上面`表1`和`表2`所示，通过字段`ID`，`表1`中的一条记录只能匹配`表2`中的一条记录，反之亦然，这就是`一对一`的关系。

### 16.2 一对多/多对一

一对多，即**一张表中的记录可以对应另外一张表中的多条记录，但是反过来，另外一张表中的一条记录只能对应第一张表中的一条记录**。

例如，咱们设计「国家城市表」，其包含两个实体，即国家和城市。

**表 3：国家表**

![3](http://img.blog.csdn.net/20170601085541820)

**表 4：城市表**

![4](http://img.blog.csdn.net/20170601085555233)

如上面`表3`和`表4`所示，通过字段`国家`，`表3`中的一条记录可以匹配`表4`中的多条记录，但反过来，`表4`中的一条记录只能匹配`表3`中的一条记录，这就是典型的`一对多`的关系。

### 16.3 多对多

多对多，即**一张表中的记录可以对应另外一张表中的多条记录，反过来，另外一张表中的一条记录也可以对应第一张表中的多条记录**。

例如，咱们设计「教师学生表」，其包含两个实体，即教师和学生。

**表 5：教师表**

![5](http://img.blog.csdn.net/20170601085610524)

**表 6：学生表**

![6](http://img.blog.csdn.net/20170601085624014)

观察上面的`表5`和`表6`，咱们会发现：`表5`和`表6`的设计满足了实体的属性，但没有维护实体之间的关系，即一个老师教过多个学生，一个学生也被多个老师教过。但是无论咱们在`表5`中还是在`表6`中增加字段，都会出现一个问题，那就是：该字段要保存多个数据，并且还是与其他表有关系的字段，不符合设计规范。因此，咱们可以再设计一张「中间表」，专门用来维护`表5`和`表6`的关系。

**表 7：中间表**

![7](http://img.blog.csdn.net/20170601085636952)

观察上面的`表5`、`表6`和`表7`，咱们会发现增加`表7`之后，咱们维护`表5`和`表6`的关系更加方便啦！无论是想从`表5`通过`表7`查到`表6`，还是想从`表6`通过`表7`查到`表5`，都非常容易啦！这就是典型的`多对多`的关系。


----------

## 17. 范式

范式：`Normal Farmat`，**是为了解决数据的存储和优化问题**。

在数据存储之后，凡是能够通过关系寻找出来的数据，坚决不再重复存储，范式的终极目标是减少数据冗余。

范式是一种分层结构的规范，共 6 层，分别为`1NF`、`2NF`、`3NF`、`4NF`、`5NF`和`6NF`，每一层都比上一层严格，若要满足下一层范式，其前提是先满足上一层范式。其中，`1NF`是最底层的范式，`6NF`为最高层的范式，也最严格。

MySQL 数据库属于关系型数据库，其存储数据的时候有些浪费空间，但也致力于节省空间，这就与范式想要解决的问题不谋而合，因此在设计数据库的时候，大都会利用范式来指导设计。但是数据库不单是要解决存储空间的问题，还要保证效率的问题，而范式只为解决存储空间的问题，所以数据库的设计又不能完全按照范式的要求来实现，因此在一般情况下，只需要满足前三种范式即可。

此外，咱们需要知道：**范式在数据库的设计中是有指导意义的，但不是强制规范**。

## 17.1 1NF

第一范式：在设计表存储数据的时候，如果表中设计的字段存储的数据，在取出来使用之前还需要额外的处理（拆分），那么表的设计就不满足第一范式，**第一范式要求字段的数据具有原子性，不可再分**。

例如，咱们设计一个「学校假期时间表」，如下所示：

**表 1：学校假期时间表**

| ID(P) | 学校名称 | 起始日期，结束日期|
| ------------- |:-------------| :-----|
|1|	哈尔滨工业大学	|20170625，20170903|
|2	|浙江大学	|20170630，20170901|

观察上表，咱们会发现`表1`的设计并没有什么问题，但是如果需求是查询各学校开始放假的日期呢？那显然上表的设计并不满足`1NF`，数据不具有原子性。对于此类问题，解决的方案就是将`表1`进行拆分：

**表 2：拆分后的表 1**

| ID(P) | 学校名称 | 起始日期|结束日期|
| ------------- |:-------------| :-----|:-----|
|1|	哈尔滨工业大学	|20170625|20170903|
|2	|浙江大学	|20170630|20170901|


## 17.2 2NF

第二范式：在数据表的设计过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来确定，而是依赖复合主键中的某个字段（主键的部分），也就是说存在字段依赖主键的部分的问题（称之为部分依赖），**第二范式就是要解决表设计中不允许出现部分依赖**。

例如，咱们设计一个「教室授课表」，如下所示：

**表 3：教室授课表**

| 教师(P) | 性别 | 课程|授课地点(P)|
| ------------- |:-------------| :-----|:-----|
|许仙| 男 |《如何追到心爱的女孩》|杭州西湖|
|白娘子	|女	|《论女人的恋爱修养》|雷峰塔|
|白娘子	|女	|《如何打赢与和尚之间的持久战》|金山寺|

观察上表，咱们会发现：教师不能作为独立的主键，需要与授课地点相结合才能作为主键（复合主键，每个教师的某个课程只能在固定的地点上），其中性别依赖于具体的教师，而课程依赖于授课地点，这就出现了表的字段依赖于部分主键的问题，从而导致不满足第二范式。

 - **解决方案 1**：将教师和性别，课程和授课地点，分成两张单独的表；
 - **解决方案 2**：取消复合主键，使用逻辑主键。

在此，咱们采用 **方案 2** 的解决方法，即取消复合主键，使用逻辑主键。

|ID(P)| 教师 | 性别 | 课程|授课地点|
|:--------| :------------- |:-------------| :-----|:-----|
|1|许仙| 男 |《如何追到心爱的女孩》|杭州西湖|
|2|白娘子	|女	|《论女人的恋爱修养》|雷峰塔|
|3|白娘子	|女	|《如何打赢与和尚之间的持久战》|金山寺|


## 17.3 3NF 

第三范式：需要满足第一范式和第二范式，理论上讲，每张表中的所有字段都应该直接依赖主键（逻辑主键，代表是业务主键），如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现主键依赖（把这种不是直接依赖主键，而是依赖非主键字段的依赖关系，称之为传递依赖），**第三范式就是要解决表设计中出现传递依赖的问题**。

以上述的添加逻辑主键后的 **表3** 为例：

|ID(P)| 教师 | 性别 | 课程|授课地点|
|:--------| :------------- |:-------------| :-----|:-----|
|1|许仙| 男 |《如何追到心爱的女孩》|杭州西湖|
|2|白娘子	|女	|《论女人的恋爱修养》|雷峰塔|
|3|白娘子	|女	|《如何打赢与和尚之间的持久战》|金山寺|

在以上表的设计中，性别依赖教师，教师依赖主键；课程依赖授课地点，授课地点依赖主键，因此性别和课程都存在传递依赖的问题。

 - **解决方案**：将存在传递依赖的字段，以及依赖的字段本身单独取出来，形成一个单独的表，然后在需要使用对应的信息的时候，把对应的实体表的主键添加进来。

**表 4：教师表**

|TEACHER_ID(P)| 教师 | 性别 | 
|:--------| :------------- |:-------------| 
|1|许仙| 男 |
|2|白娘子	|女	|
|3|白娘子	|女	|

**表 5：授课地点表**

|ADDRESS_ID(P)|  课程|授课地点|
|:--------| :-----|:-----|
|1|《如何追到心爱的女孩》|杭州西湖|
|2|《论女人的恋爱修养》|雷峰塔|
|3|《如何打赢与和尚之间的持久战》|金山寺|

**表 6：进行处理后的表**

|ID(P)|  TEACHER_ID|ADDRESS_ID|
|:--------| :-----|:-----|
|1|1|1|
|2|2|2|
|3|3|3|

在观察上述 **表 4** 和 **表 5**，咱们会发现`TEACHER_ID`等价于`教师`且`ADDRESS_ID`等价于`授课地点`，因此其逻辑主键并没有什么实际的限制意义，咱们只需要看其具体代表的业务主键即可。咱们之所以使用逻辑主键，是因为：**逻辑主键可以实现自动增长，并且数字传递比较方便，而且有利于节省空间**。

## 17.4 逆规范化

在某些特定的环境中（例如淘宝数据库），在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取数据，理论上讲，的确可以获得想要的数据，但是相对来说，其效率低会一点。此时为了提高查询效率，咱们会刻意的在某些表中，不去保存另外一张表的主键（逻辑主键），而是直接保存想要存储的数据信息，这样的话，在查询数据的时候，这张表就可以直接提供咱们想要的数据，而不需要多表查询，但是这样做会导致数据冗余。

实际上，**逆规范化是磁盘利用率和效率之间的对抗**。

----------

## 18. 数据的高级操作

数据的操作，无外乎**增删改查**。

新增数据的基本语法为：

 - `insert into + 表名 + [(字段列表)] + values (值列表);`

在数据插入的时候，假设主键对应的值已经存在，则插入失败！这就是主键冲突。

### 18.1 主键冲突

当主键存在冲突（duplicate key）的时候，可以选择性的进行处理，即更新或替换。

下面，以表`my_class`为例，进行测试：

![1](http://img.blog.csdn.net/20170603202002804)

其中，`grade`为主键。

**第一种情况：主键冲突，进行更新操作。**

 - 基本语法：`insert into + 表名 + [(字段列表：包含主键)] + values (值列表) on duplicate key update 字段 = 新值;`

执行如下 SQL 语句，进行测试：

```
-- 测试主键冲突的 SQL 语句
insert into my_class values ('PM3527','B315');
```

![2](http://img.blog.csdn.net/20170603202439264)

如上图所示，当主键已经存在的时候，产生主键冲突。再执行如下 SQL 语言，解决主键冲突的问题：

```
-- 当主键冲突的时候，进行更新操作
insert into my_class values ('PM3527','B315')
-- 冲突处理
on duplicate key update
-- 更新主键值
room = 'B315';
```

![3](http://img.blog.csdn.net/20170603202810534)

**第二种情况：主键冲突，选择替换操作。**

 - 基本语法：`replace insert into + 表名 + [(字段列表：包含主键)] + values (值列表);`

执行如下 SQL 语句，进行测试：

```
-- 测试主键冲突的 SQL 语句
insert into my_class values ('PM3528','B215');
```

![4](http://img.blog.csdn.net/20170603203053592)

如上图所示，当主键已经存在的时候，产生主键冲突。再执行如下 SQL 语言，解决主键冲突的问题：

```
-- 当主键冲突的时候，进行替换操作
replace into my_class values ('PM3528','B215');
```

![5](http://img.blog.csdn.net/20170603203402011)

通过以上两种情况的演示，当再发生主键冲突的时候，咱们已经可以从容应对并解决啦！


----------

### 18.2 蠕虫复制

蠕虫复制：从已有的数据表中获取数据，然后将数据进行新增操作，数据成倍（以指数形式）的增加。

**根据已有表创建新表，即复制表结构**，其基本语法为：

 - `create table + 表名 + like + [数据库名.]表名;`

执行如下 SQL 语句，进行测试：

```
-- 根据已有表，创建新表，当两张表位于同一数据库时，可以省略数据库名称
create table my_copy like my_gbk;
```

![6](http://img.blog.csdn.net/20170603205833948)

如上图所示，表`my_copy`和表`my_gbk`的表结构完成相同。

蠕虫复制的步骤为：先查出数据，然后将查出的数据新增一遍。

 - **基本语法**：`insert into + 表名 + [()] + select + 字段列表/* + from + 表名;`

执行如上 SQL 语句，进行测试：

```
-- 蠕虫复制
insert into my_copy select * from my_collate_bin;
```

![7](http://img.blog.csdn.net/20170603210620720)

如上图所示，咱们已经成功将表`my_collate_bin`中的数据复制到表`my_copy`中啦！接下来，咱们再执行如下 SQL 语句，测试蠕虫复制的效果：

```
-- 蠕虫复制
insert into my_copy select * from my_copy;
```

![8](http://img.blog.csdn.net/20170603210950502)

如上图所示，通过观察每次执行 SQL 语句后影响的列数，分别为`4`、`8`和`16`等，咱们会发现蠕虫复制的效果呈（指数）爆炸性增长。

**蠕虫复制的意义**：

 1. 从已有的数据表中拷贝数据到新的数据表；
 2. 可以迅速的让表中的数据膨胀到一定的数量级，多用于测试表的压力及效率。

----------

### 18.3 更新数据

 - **基本语法**： `update + 表名 + set + 字段 = 值 + [where 条件];`
 - **高级语法**： `update + 表名 + set + 字段 = 值 + [where 条件] + [limit 更新数量];`

执行如下 SQL 语句，进行测试：

```
-- 将表 my_copy 中的部分 a 更新为 c
update my_copy set name = 'c' where name = 'a' limit 3;
```

执行上述 SQL 语句前：

![1](http://img.blog.csdn.net/20170625180810447)

执行上述 SQL 语句后：

![2](http://img.blog.csdn.net/20170625180922214)


### 18.4 删除数据

与更新类似，可以通过`limit`来限制删除的数量。

 - **基本语法**： `delete + from + 表名 + [where 条件];`
 - **高级语法**： `delete + from + 表名 + [where 条件] + [limit 删除数量];`

执行如下 SQL 语句，进行测试：

```
-- 将表 my_copy 中的部分 b 删除
delete from my_copy where name = 'b' limit 10;
```

![3](http://img.blog.csdn.net/20170625181516023)

此外，在删除记录的过程中，**如果表中存在自增长的主键，那么删除之后，自增长不会还原**。执行如下 SQL 语句，进行测试：

```
-- 删除表 student 中的记录，查看自增长属性
delete from student;
show create table student;
```

![4](http://img.blog.csdn.net/20170625182444031)


如上图所示，显然在咱们删除表`student`中的全部数据之后，`id`的自增长属性值`3`并没有发生改变，这是因为数据的删除是不会改变表结构的。如果想要还原自增长属性，思路是：**先删除表，然后重新建表**。

 - **基本语法**：`truncate + 表名;`

执行如下 SQL 语句，进行测试：

```
-- 先清空 student 表，再重新创建 student 表
truncate student;
```

![5](http://img.blog.csdn.net/20170625183121678)

如上图所示，显然咱们已经测试成功啦！


----------

## 19. 查询数据

 - **基本语法**： `select + 字段列表/* + from + 表名 + [where 条件];`
 - **完整语法**： `select + [select 选项] + 字段列表[字段别名]/* + from + 数据源 + [where 条件] + [1] + [2] + [3];`
	 + `[1] = [group by 子句]`
	 + `[2] = [order by 子句]`
	 +  `[3] = [limit 子句]`

### 19.1 SELECT 选项

`select`选项，即`select`对查出来的结果的处理方式。

 - `all`：默认，保留所有的查询结果；
 - `distinct`：去重，将查出来的结果中所有字段都相同的记录去除。

执行如下 SQL 语句，进行测试：

```
-- 查询表 my_copy 中的数据
select * from my_copy;
select all * from my_copy;
select distinct * from my_copy;
```

![6](http://img.blog.csdn.net/20170625210624498)


### 19.2 字段别名

字段别名，即当数据进行查询的时候，有时候字段的名字并不一定满足需求（特别地，在多表查询的时候，很可能会有同名字段），这时就需要对字段进行重命名、取别名。

 - **基本语法**：`字段名 + [as] + 别名;`

执行如下 SQL 语句，进行测试：

```
-- 使用别名
select id,
name as 姓名,
age as 年龄，
grade as 年级
from student;
```

![7](http://img.blog.csdn.net/20170625215451466)

### 19.3 数据源

数据源，即数据的来源，关系型数据库的数据源都是数据表，本质上只要保证数据类似二维表，最终就可以作为数据源。

数据源分为 3 种，分别为：单表数据源，多表数据源和查询语句。

**第 1 种**：单表数据源

 - **基本语法**：`select * from + 表名;`

![8](http://img.blog.csdn.net/20170625220806193)

**第 2 种**：多表数据源

 - **基本语法**：`select * from + 表名1,表名2...;`

![9](http://img.blog.csdn.net/20170625221005836)

如上图所示，使用多表数据源时默认从一张表中取出一条记录去另外一张表中匹配所有记录，而且全部保留，比较浪费资源，应该尽量避免。


**第 3 种**：查询语句（子查询）

 - **基本语法**：`select * from + (select * from + 表名) + [as] + 别名;`

![10](http://img.blog.csdn.net/20170625221630276)

如上图所示，数据的来源是一条查询语句，而查询语句的结果是一张二维表。


### 19.5 `where`子句

`where`字句：**用来判断数据和筛选数据，返回的结果为`0`或者`1`，其中`0`代表`false`，`1`代表`true`**，`where`是唯一一个直接从磁盘获取数据的时候就开始判断的条件，从磁盘中读取一条数据，就开始进行`where`判断，如果判断的结果为真，则保持，反之，不保存。

**判断条件**：

 - 比较运算符：`>`、`<`、`>=`、`<=`、`<>`、`=`、`like`、`between and`、`in`和`not in`；
 - 逻辑运算符：`&&`、`||`、和`!`.


执行如下 SQL 语句，进行测试：

```
-- 查询表 student 中 id 为 2、3、5 的记录
select * from student where id = 2 || id = 3 || id = 5;
select * from student where id in (2,3,5); 
```

![001](http://img.blog.csdn.net/20170627210129189)

```
-- 查询表 student 中 id 在 2 和 5 之间的记录
select * from student where id between 2 and 5;
```

![002](http://img.blog.csdn.net/20170627210410567)

如上图所示，咱们会发现：**在使用`between and`的时候，其选择的区间为闭区间，即包含端点值**。此外，`and`前面的数值必须大于等于`and`后面的数值，否则会出现空判断，例如：

![003](http://img.blog.csdn.net/20170627210829379)


### 19.6 `group by`子句

`group by`子句：**根据表中的某个字段进行分组，即将含有相同字段值的记录放在一组，不同的放在不同组**。

 - **基本语法**：`group by + 字段名;`

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据按字段 sex 进行分组
select * from student group by sex;
```

![004](http://img.blog.csdn.net/20170627211555446)

观察上图，咱们会发现：表`student`在分组过后，数据“丢失”啦！实际上并非如此，产生这样现象原因为：**`group by`分组的目的是为了（按分组字段）统计数据，并不是为了单纯的进行分组而分组**。为了方便统计数据，SQL 提供了一系列的统计函数，例如：

 - `cout()`：统计分组后，每组的总记录数；
 - `max()`：统计每组中的最大值；
 - `min()`：统计每组中的最小值；
 - `avg()`：统计每组中的平均值；
 - `sum()`：统计每组中的数据总和。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据按字段 sex 进行分组，并进行统计
select sex,count(*),max(age),min(age),avg(age),sum(age) from student group by sex;
```
![005](http://img.blog.csdn.net/20170627212554643)

其中，`count()`函数里面可以使用两种参数，分别为：`*`表示统计组内全部记录的数量；`字段名`表示统计对应字段的非`null`（如果某条记录中该字段的值为`null`，则不统计）记录的总数。此外，使用`group by`进行分组之后，展示的记录会根据分组的字段值进行排序，默认为升序。当然，也可以人为的设置升序和降序。

 - **基本语法**：`group by + 字段名 + [asc/desc];`

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据按字段 sex 进行分组，并排序
select sex,count(*) from student group by sex;
select sex,count(*) from student group by sex asc;
select sex,count(*) from student group by sex desc;
```
![006](http://img.blog.csdn.net/20170627213601017)

通过观察上面数个分组示例，细心的同学会发现：咱们在之前的示例中，都是用单字段进行分组。实际上，咱们也可以使用**多字段分组**，即：**先根据一个字段进行分组，然后对分组后的结果再次按照其他字段（前提是分组后的结果中包含此字段）进行分组**。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据先按字段 grade 进行分组，再按字段 sex 进行分组
select *,count(*) from student group by grade,sex;
```

![007](http://img.blog.csdn.net/20170627214720585)

在这里，函数`group_concat(字段名)`可以对分组的结果中的某个字段值进行字符串连接，即保留该组某个字段的所有值。例如：

```
-- 将表 student 中的数据按字段 sex进行分组，并保留字段 name 的值
select sex,age,count(*),group_concat(name) from student group by sex;
```
![008](http://img.blog.csdn.net/20170627215231647)

此外，简单介绍**回溯统计**的概念：**利用`with rollup`关键字（书写在 SQL 语句末尾），可以在每次分组过后，根据当前分组的字段进行统计，并向上一级分组进行汇报**。例如：

```
-- 将表 student 中的数据按字段 sex进行分组，并进行回溯统计
select sex,count(*) from student group by sex with rollup;
```
![009](http://img.blog.csdn.net/20170627220823491)

观察上图，咱们会发现：**在进行回溯统计的时候，会将分组字段置空**。


### 19.7 `having`子句

`having`字句：**与`where`子句一样，都是进行条件判断的**，但是`where`是针对磁盘数据进行判断，数据进入内存之后，会进行分组操作，分组结果就需要`having`来处理。思考可知，`having`能做`where`能做的几乎所有事情，但是`where`却不能做`having`能做的很多事情。

**第 1 点：分组统计的结果或者说统计函数只有`having`能够使用**

执行如下 SQL 语句，进行测试：

```
-- 求出表 student 中所有班级人数大于等于 2 的班级
select grade,count(*) from student group by grade having count(*) >= 2;
select grade,count(*) from student where count(*) >= 2 group by grade;
```

![1](http://img.blog.csdn.net/20170711085904967)

如上图所示，显然`having`子句可以对统计函数得到的结果进行筛选，但是`where`却不能。

**第 2 点：`having`能够使用字段别名，`where`则不能**

执行如下 SQL 语句，进行测试：

```
-- 求出表 student 中所有班级人数大于等于 2 的班级
select grade,count(*) as total from student group by grade having total >= 2;
select grade,count(*) as total from student where total >= 2 group by grade;
```

![2](http://img.blog.csdn.net/20170711090554273)

如上图所示，显然咱们的结论得到了验证。究其原因，`where`是从磁盘读取数据，而磁盘中数据的名字只能是字段名，别名是数据（字段）进入到内存后才产生的。值得注意的是，**在上述 SQL 语句中咱们使用了字段别名，这在无意中就优化了 SQL 并提高了效率，因为少了一次统计函数的计算**。


### 19.8 `order by`子句

`order by`子句：**根据某个字段进行升序或者降序排序，依赖校对集**。

 - **基本语法**：`order by + [asc/desc];`

其中，`asc`为升序，为默认值；`desc`为降序。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据按年龄 age 进行排序
select * from student order by age;
```

![3](http://img.blog.csdn.net/20170711091902136)

此外，咱们可以进行「**多字段排序**」，即**先根据某个字段进行排序，然后在排序后的结果中，再根据某个字段进行排序**。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 中的数据先按年龄 age 升序排序，再按班级 grade 降序排序
select * from student order by age,grade desc;
```

![4](http://img.blog.csdn.net/20170711093201665)


### 19.9 `limit`子句

`limit`子句：**是一种限制结果的语句，通常来限制结果的数量**。

 - **基本语法**：`limit + [offset] + length;`

其中，`offset`为起始值；`length`为长度。

**第 1 种：只用来限制长度（数据量）**

执行如下 SQL 语句，进行测试：

```
-- 查询表 student 中的全部记录
select * from student;
-- 查询表 student 中的 3 条记录
select * from student limit 3;
```
![00](http://img.blog.csdn.net/20170711192158394)


**第 2 种：限制起始值，限制长度（数据量）**

执行如下 SQL 语句，进行测试：

```
-- 查询表 student 中的记录
select * from student limit 0,2;
-- 查询表 student 中的记录
select * from student limit 2,2;
```

![01](http://img.blog.csdn.net/20170711192515751)

**第 3 种：主要用来实现数据的分页，目的是为用户节省时间，提高服务器的响应效率，减少资源的浪费**

大致设计：

 - 对于用户来讲，可以通过点击页码按钮，如`1`、`2`、`3`等来进行选择；
 - 对于服务器来讲，可以根据用户选择的页码来获取不同的数据。

其中，

 - `length`：表示每页的数据量，基本不变；
 - `offset`：表示每页的起始值，公式为`offset=(页码-1)*length`.

如果大家感兴趣的话，可以结合`Java`或者其他语言进行测试。


----------

## 20. 连接查询

**连接查询**：将多张表（大于等于 2 张表）按照某个指定的条件进行数据的拼接，其最终结果记录数可能有变化，但字段数一定会增加。

**连接查询的意义**：在用户查询数据的时候，需要显示的数据来自多张表。

连接查询为`join`，使用方式为：**左表`join`右表**。

 - 左表：`join`左边的表；
 - 右表：`join`右边的表。

**连接查询分类**：在 SQL 中将连接查询分为四类，分别为内连接、外链接、自然连接和交叉连接。


### 20.1 交叉连接

**交叉连接**：`cross join`，从一张表中循环取出每一条记录，每条记录都去另外一张表进行匹配，匹配的结果都保留（没有条件匹配），而连接本身的字段会增加，最终形成的结果为笛卡尔积形式。

 - **基本语法**：`左表 cross join 右边;`

其结果与多表查询相同。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行交叉连接
select * from student cross join class;
-- 将表 student 与 class 进行多表查询
select * from student,class;
```

![01](http://img.blog.csdn.net/20170711212738238)

实际上，笛卡尔积形式（交叉连接和多表查询）的结果并没有什么实际意义，应该尽量避免，其存在的价值就是保证连接这种结构的完整性。

#### 20.1.1 内连接

**内连接**：`inner join`，从左表中取出每一条记录，和右表中的所有记录进行匹配，并且仅当某个条件在左表和右表中的值相同时，结果才会保留，否则不保留。

 - **基本语法**：`左表 + [inner] + join + 右表 + on + 左表.字段 = 右表.字段;`

其中，关键字`on`表示连接条件，两表中的条件字段有着相同的业务含义。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行内连接
select * from student inner join class on student.grade = class.grade;
select * from student join class on student.grade = class.grade;
```

![innerjoin](http://img.blog.csdn.net/20170714225952197)

在这里，值得注意的是：**如果两表中有某个表的条件字段名唯一，那么在书写连接条件的时候，可以省略表名，直接书写字段名，MySQL 会自动识别唯一字段名，但不建议这么做**。此外，咱们会发现，在上面的结果中有同名字段，这会给咱们理解数据的意义造成一定的困扰，这时就需要使用字段别名和表别名做区别啦！

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行内连接，起别名
select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c on s.grade = c.grade;
```

![alias](http://img.blog.csdn.net/20170714232531767)

最后，内连接可以没有连接条件，即可以没有`on`及之后的内容，这时内连接的结果全部保留，与交叉连接的结果完全相同。而且在内连接的时候可以使用`where`关键字代替`on`，但不建议这么做，因为`where`没有`on`的效率高。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行内连接，不加连接条件
select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c;

-- 将表 student 与 class 进行交叉连接 
select s.*,c.id as c_id,c.grade as c_grade,room from student as s cross join class as c;

-- 使用 on 关键字进行内连接
select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c on s.grade = c.grade;

-- 使用 where 关键字进行内连接
select s.*,c.id as c_id,c.grade as c_grade,room from student as s inner join class as c where s.grade = c.grade;
```

![onon](http://img.blog.csdn.net/20170714233908019)
![whereon](http://img.blog.csdn.net/20170714233930361)

#### 20.1.2 外连接

**外连接**：`left\right join`，以某张表为主表，取出里面的所有记录，然后让主表中的每条记录都与另外一张表进行连接，不管能否匹配成功，其最终结果都会保留，匹配成功，则正确保留；匹配失败，则将另外一张表的字段都置为`NULL`.

 - **基本语法**：`左表 + left\right + join + 右表 + on + 左表.字段 = 右表.字段;`

其中，关键字`on`表示连接条件，两表中的条件字段有着相同的业务含义。在这里，以主表为依据，外连接分为两种，分别为：

 - `left join`：左外连接（左连接），以左表为主表；
 - `right join`：右外连接（右连接），以右表为主表。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行左连接
select s.*,c.id as c_id,c.grade as c_grade,room from student as s left join class as c on s.grade = c.grade;

-- 将表 student 与 class 进行右连接
select s.*,c.id as c_id,c.grade as c_grade,room from student as s right join class as c on s.grade = c.grade;
```

![outer](http://img.blog.csdn.net/20170715000220792)

实际上，无论以那张表为主表，其外连接的结果（记录数量）都不会少于主表的记录总数。此外，虽然左连接与右连接有主表差异，但显示的结果都是：**左表的数据在左边，右表的数据在右边**。


### 20.2 自然连接


**自然连接**：`nature join`，自然连接其实就是自动匹配连接条件，系统以两表中同名字段作为匹配条件，如果两表有多个同名字段，那就都作为匹配条件。在这里，自然连接可以分为自然内连接和自然外连接。

#### 20.2.1 自然内连接

 - **基本语法**：`左表 + nature + join + 右表;`

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行自然内连接
select * from student natural join class;

-- 将表 student 与 class 进行内连接，连接条件为 id 和 grade
select * from student inner join class on student.id = class.id and student.grade = class.grade;
```

![natural](http://img.blog.csdn.net/20170715103845312)

观察上图，咱们会发现：**自然连接自动使用同名字段作为连接条件，而且在连接完成之后合并同名字段**。

#### 20.2.2 自然外连接

 - **基本语法**：`左表 + nature + left/right + join + 右表;`

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行自然左外连接
select * from student natural left join class;

-- 将表 student 与 class 进行自然右外连接
select * from student natural right join class;
```

![naturalwai](http://img.blog.csdn.net/20170715104058311)

实际上，自然连接并不常用。而且，咱们可以用内连接和外连接来模拟自然连接，模拟的关键就在于使用同名字段作为连接条件及合并同名字段。

 - **基本语法**：`左表 + inner/left/right + join + 右表 + using(字段名);`

其中，`using`内部的字段名就是作为连接条件的字段，也是需要合并的同名字段。

执行如下 SQL 语句，进行测试：

```
-- 将表 student 与 class 进行自然左外连接
select * from student natural left join class;

-- 用左外连接模拟自然左外连接
select * from student left join class using(id,grade);
```

![moni](http://img.blog.csdn.net/20170715105006248)

----------


## 21. 外键

**外键**：`foreign key`，外面的键，即不在自己表中的键。如果一张表中有一个非主键的字段指向另外一张表的主键，那么将该字段称之为外键。每张表中，可以有多个外键。

### 21.1 新增外键

外键既可以在创建表的时候增加，也可以在创建表之后增加（但是要考虑数据的问题）。

**第 1 种：在创建表的时候，增加外键**

 - **基本语法**：`foreign key(外键字段) + references + 外部表名(主键字段);`

执行如下 SQL 语句，进行测试：

```
-- 创建外键
create table my_foreign1(
	id int primary key auto_increment,
	name varchar(20) not null comment '学生姓名',
	c_id int comment '班级表ID',
	-- 增加外键
	foreign key(c_id) references class(id)	
)charset utf8;
```

![foreign1](http://img.blog.csdn.net/20170819224902221)

观察上图可知，字段`c_id`的`key`显示为`MUL`，表示多个键的意思。这是因为外键要求字段本身是一个索引（普通索引）如果字段本身没有索引，外键就会先创建一个索引，然后才创建外键本身。此外，`CONSTRAINT`后面的`my_foreign_ibfk_1`表示外键的名字。

**第 2 种：在创建表之后，增加外键**

 - **基本语法**：`alter table + 表名 + add[constraint + 外键名字] + foreign key(外键字段) + references + 外部表名(主键字段);`

执行如下 SQL 语句，进行测试：

```
-- 创建外键
create table my_foreign2(
	id int primary key auto_increment,
	name varchar(20) not null comment '学生姓名',
	c_id int comment '班级表ID'
)charset utf8;

-- 增加外键
alter table my_foreign2 add
-- 指定外键名
constraint test_foreign
-- 指定外键字段
foreign key(c_id)
-- 引用外部表主键
references class(id);
```

![foreign2](http://img.blog.csdn.net/20170819230041629)

如上图所示，显然咱们已经增加外键成功啦！



### 21.2 修改外键 & 删除外键

外键不能修改，只能先删除后增加。

 - **基本语法**：`alter table + 表名 + drop foreign key + 外键名字;`

执行如下 SQL 语句，进行测试：

```
-- 删除外键
alter table my_foreign1 drop foreign key my_foreign1_ibfk_1;
```

![foreign3](http://img.blog.csdn.net/20170819231014775)

观察上图可知，删除外键不能通过查看表结构来体现，而是应该通过创建表的语句来查看。

### 21.3 外键作用

首先，给出父表和子表的定义：

 - **父表**，指外键所指向的表；
 - **子表**，指相对于父表，拥有外键的表。

外键默认的作用有两个，分别对子表和父表进行约束。

**第 1 种：约束子表**

在子表进行数据的写操作（增和改）的时候，如果对应的外键字段在父表找不到对应的匹配，那么操作就会失败。

执行如下 SQL 语句，进行测试：

```
-- 插入数据，外键字段在父表不存在
insert into my_foreign2 values(null,'Charies','6'); 

-- 插入数据，外键字段在父表存在
insert into my_foreign2 values(null,'Charies','1'); 
```

![foreign4](http://img.blog.csdn.net/20170820105124647)

如上图所示，在我们向子表`my_foreign2`插入外键字段为`6`的时候，提示插入失败，原因就是在父表`class`中，没有`ID`为`6`的记录。而在我们向子表`my_foreign2`插入外键字段为`1`的时候，提示成功，原因就是在父表`class`中，有`ID`为`1`的记录。

**第 2 种：约束父表**

在父表进行数据的写操作（删和改，且涉及主键）的时候，如果对应的主键字段在子表已经被数据引用，那么操作就会失败。

执行如下 SQL 语句，进行测试：

```
-- 更新父表记录
update class set id = 5 where id = 1;
update class set id = 5 where id = 3;
```

![foreign5](http://img.blog.csdn.net/20170820110130835)

如上图所示，在我们修改父表`class`中`ID`为`1`的时候，提示修改失败，原因就是在子表`my_foreign2`中已经引用了该值的主键字段。而在我们修改父表`class`中`ID`为`3`的时候，提示修改成功，原因就是在子表`my_foreign2`中并没有引用该值的主键字段。

#### 21.4 外键条件

在我们使用外键的时候，应该遵循如下条件：

- 外键要存在，首先必须保证表的引擎是 InnoDB（默认的存储引擎），如果不是 InnoDB 存储引擎，那么外键可以创建成功，但没有约束作用；
- 外键字段的字段类型（列类型），必须与父表的主键类型完全一致；
- 每张表中的外键名称不能重复；
- 增加外键的字段，如果数据已经存在，那么要保证数据与父表中的主键对应。

下面以最后一个条件为例，执行如下 SQL 语句，进行测试：

```
-- 新增数据
insert into my_foreign1 valuse(1,'Gavin',3);

-- 增加外键
alter table my_foreign1 add foreign key(c_id) references class(id);
```

![foreign6](http://img.blog.csdn.net/20170820112819179)

如上图所示，在新增外键的时候，如果子表中（想要新增外键的字段）的数据已经存在，而父表中又没有与子表中（想要新增外键的字段）的数据相匹配的主键的话，那么操作就会失败；反之，则会成功。

执行如下 SQL 语句，进行测试：

```
-- 新增数据
insert into class valuse(3,'PM3.4','A115');

-- 增加外键
alter table my_foreign1 add foreign key(c_id) references class(id);
```

![foreign7](http://img.blog.csdn.net/20170820113638418)

如上图所示，显然当父表中存在与子表中（想要新增外键的字段）的数据相匹配的主键的话，增加主键的操作就会成功。

#### 21.5 外键约束

所谓外键约束，就是指外键的作用。之前所讲的外键的作用都是默认的作用，实际上，可以通过对外键的需求，进行定制操作。

外键约束有三种模式，分别为：

 - `district`：严格模式（默认），父表不能删除或更新一个已经被子表数据引用的记录；
 - `cascade`：级联模式，父表的操作，对应子表关联的数据也跟着被删除；
 - `set null`：置空模式，父表的操作之后，子表对应的数据（外键字段）被置空。

在此需要注意：**以上三种模式，都是对父表的约束**。

 - **基本语法**：`foreign key(外键字段) + references + 父表(主键字段) + [on delete + 模式 + on update + 模式];`

通常一个合理的做法（约束模式）是：删除的时候，	子表被置空；更新的时候，子表进行级联操作。

执行如下 SQL 语句，进行测试：

```
-- 创建外键，指定模式：删除置空，更新级联
create table my_foreign3(
	id int primary key auto_increment,
	name varchar(20) not null,
	c_id int,
	-- 增加外键
	foreign key(c_id)
	-- 引用父表
	references class(id)
	-- 指定删除模式
	on delete set null
	-- 指定更新模式
	on update cascade
)charset utf8;
```

![foreign8](http://img.blog.csdn.net/20170820122712734)

如上图所示，在我们指定外键的约束模式之后，通过查看表的创建语句，可以看到具体的约束语句。

接下来，执行如下 SQL 语句，继续进行测试：

```
-- 插入数据
insert into my_foreign3 values(null,'Jobs',1),
(null,'Bill',1),
(null,'Mark',1),
(null,'Swift',2),
(null,'Sellen',1);
```
![foreign9](http://img.blog.csdn.net/20170820123421517)

如上图所示，我们向表`my_foreign3`中插入了 5 条记录。接下来，我们就可以测试外键的级联模式和置空模式啦！呃，对啦，前提是我们需要把与父表`class`相关联的除`my_foreign3`之外的其他子表，也就是`my_foreign1`和`my_foreign2`的外键删除掉，否则的话，由于这两个子表的外键使用了严格模式，会干扰我们接下来的测试。

在我们删除表`my_foreign1`和`my_foreign2`的外键之后，执行如下 SQL 语句，测试级联模式：

```
-- 更新父表主键
update class set id = 8 where id = 1;
```

![foreign10](http://img.blog.csdn.net/20170820124603611)

执行如下 SQL 语句，测试置空模式：

```
-- 删除父表主键
delete from class where id = 2;
```

![foreign11](http://img.blog.csdn.net/20170820124914320)

通过以上测试，我们已经验证了级联模式和置空模式的效果。其实，在我们进行删除置空操作的时候，有一个前提，那就是：**子表的外键字段必须允许为空，否则的话，操作是无法成功的**。	

至此，我们已经把外键的相关操作都演示了一遍。在这里，我们会发现外键的功能非常强大，能够进行各种的约束，也正是由于外键这种约束的强大，其降低了开发语言对数据的可控性，因此在实际的开发中，很少使用外键来处理数据。


----------

## 22. 联合查询

**联合查询**：`union`，将多次查询（多条`select`语句）的结果，在字段数相同的情况下，在记录的层次上进行拼接。

### 22.1 基本语法

联合查询由多条`select`语句构成，每条`select`语句获取的字段数相同，但与字段类型无关。

 - **基本语法**：`select 语句1 + union + [union选项] + select 语句2 + ...;`
  - **union 选项**：与`select`选项一样有两种
     - `all`：无论重复与否，保留所有记录；
     - `distinct`：表示去重，为默认选项。

执行如下 SQL 语句，进行测试：

```
-- 联合查询，默认去重
select * from class
union distinct
select * from class;

-- 联合查询，保留所有记录
select * from class
union all
select * from class;
```

![union1](http://img.blog.csdn.net/20170826203614206)

如上图所示，展示了联合查询的两种形式。特别地，联合查询只要求字段数相同，而跟类型无关。执行如下 SQL 语句，进行测试：

```
-- 联合查询，字段数相同，类型不同
select id, grade, room from class
union distinct
select name, age, id from student;
```

![UNION2](http://img.blog.csdn.net/20170826204215277)

如上图所示，联合查询只保留了第一张表的字段，而不保留第二张表的字段。

### 22.2 意义

联合查询的意义有两种，分别为：

 - 查询同一张表，按时需要不同，例如查询学生信息，要求男生按年龄升序排序，女生按年龄降序排序；
 - 多表查询，多张表的结构是完全一样的，保持的数据结构也是一样的。

此外，如果数据量非常的大，就要进行分表（垂直分表和水平分表），而分表的依据无外乎数据多不多和常不常用。

### 22.3 排序

首先，让我们看看`student`表中的数据：

![student](http://img.blog.csdn.net/20170826212532276)

接下来，给出一个需求：**在`student`表中，让男生按年龄升序排序，让女生按年龄降序排序**。根据我们刚刚学到的联合查询，貌似很容易啊！执行如下 SQL 语句，进行测试：

```
-- 在 student 表中，按年龄，男升女降
select * from student where gender = "boy" order by age asc
union
select * from student where gender = "girl" order by age desc;
```

![order1](http://img.blog.csdn.net/20170826213018938)

如上图所示，呃，好吧，貌似出错啦！这是因为要想在联合查询中使用`order by`，我们必须将`select`语句用括号括起来。执行如下 SQL 语句，进行测试：

```
-- 在 student 表中，按年龄，男升女降
(select * from student where gender = "boy" order by age asc)
union
(select * from student where gender = "girl" order by age desc);
```

![order2](http://img.blog.csdn.net/20170826213319951)

如上图所示，啊，我们都已经将`select`语句用括号括起来了，但是男生和女生也没有按我们的目的实现啊！好吧，这是因为要想在联合查询中使`order by`生效，我们必须将其与`limit`搭配使用，而`limit`的限定数，我们设置为一个非常大的数即可。执行如下 SQL 语句，进行测试：

```
-- 在 student 表中，按年龄，男升女降
(select * from student where gender = "boy" order by age asc limit 666)
union
(select * from student where gender = "girl" order by age desc limit 666);
```

![order](http://img.blog.csdn.net/20170826214015483)

如上图所示，显然，这次咱们的目的实现啦！

----------

## 23. 子查询

**子查询**：`sub query`，查询是在某个查询结果之上进行的，一条`select`语句内部包含了另外一条`select`语句。

### 23.1 分类

子查询有两种分类方式，分别为：按按结果分类和位置分类。

**按结果分类**，即根据子查询得到的数据进行分类（理论上，任何一个查询结果都可以理解为一个二维表），分别为：

 - 标量子查询：子查询得到的结果是一行一列，出现的位置在`where`之后；
 - 列子查询：子查询得到的结果是一列多行，出现的位置在`where`之后；
 - 行子查询：子查询得到的结果是多行一列（多行多列），出现的位置在`where`之后；
 - 表子查询：子查询得到的结果是多行多列，出现的位置在`from`之后。


**按位置分类**，即根据子查询（`select`语句）在外部查询（`select`语句）中出现的位置进行分类，分别为：

 - `from`子查询：子查询出现在`from`之后；
 - `where`子查询：子查询出现在`where`条件之中；
 - `exists`子查询：子查询出现在`exists`里面。

### 23.2 标量子查询

**需求**：现知道班级名称为`PM3.1`，想要获取该班的全部学生。

**思路**：

 - 先确定数据源，学生表。
  - `select * from student where c_id = ?;`
 - 然后获取班级 ID，可以通过（班级表）班级名称来确定。
  - `select id from class where grade = "PM3.1";`

执行如下 SQL 语句，进行测试：

```
-- 标量子查询
select * from student where c_id = (select id from class where grade = "PM3.1");
```

![biaol](http://img.blog.csdn.net/20170826223108914)

### 23.3 列子查询

**需求**：查询所有在读班级（学生表中存在的班级）的学生。

**思路**：

 - 先确定数据源，学生表。
  - `select * from student where c_id in ?;`
 - 然后确定全部有效的班级 ID。
  - `select id from class;`

执行如下 SQL 语句，进行测试：

```
-- 列子查询
select * from student where c_id in (select id from class);
```

![column](http://img.blog.csdn.net/20170826231655784)

如上图所示，我们完成了列子查询。在列子查询的结果为一行多列时，我们需要使用`in`作为条件进行匹配；此外，在 MySQL 中还有三个类似的条件，分别为：`all`、`some`和`any`。

 - `any`等价于`in`，表示其中一个；
 - `any`等价于`smoe`，而`any`和`some`用于否定时却有些区别；
 - `all`表示等于全部。

值得注意的是，在我们使用上面三个关键字中任何一个的时候，都需要搭配`=`使用，例如：

```
-- 列子查询
select * from student where c_id = any (select id from class);

select * from student where c_id = some (select id from class);

select * from student where c_id = all (select id from class);
```

![ass](http://img.blog.csdn.net/20170826231616645)

如上图所示，为`any`、`some`和`all`的肯定用法，下面我们来测试其否定用法：

```
-- 列子查询
select * from student where c_id != any (select id from class);

select * from student where c_id != some (select id from class);

select * from student where c_id != all (select id from class);
```

![fouze](http://img.blog.csdn.net/20170826231526787)

观察上图，我们会发现`any`、`some`和`all`在用于否定时，其会将`null`值排除掉。实际上，在真正的开发中，这三个关键字并不常用。

### 23.4 行子查询

行子查询，返回的结果可以使一行多列或者多行多列。

**需求**：查询学生表中，年龄最大且身高最高的学生。

**思路**：

 - 先确定数据源，学生表。
  - `select * from student where age = ? and height = ?;`
 - 然后确定最大年龄和最大身高。
  - `select max(age), max(height) from student;`

执行如下 SQL 语句，进行测试：

```
-- 列子查询
select * from student where
-- 其中，(age, height) 称之为行元素
(age, height) = (select max(age), max(height) from student);
```

![row](http://img.blog.csdn.net/20170827105939052)

### 23.5 表子查询

表子查询，返回的结果是多行多列二维表（将子查询的结果当做二维表来使用），实际上，任何查询返回的结果都可以称之为二维表。

**需求**：找出每个班身高最高的学生。

**思路**：

 - 先确定数据源，将学生按身高进行降序排序。
  - `select * from student order by height desc;`
 - 从每个班级选出第一个学生。
  - `select * from student group by c_id;`

在这里，我们可能会有些疑问：为什么要将学生表降序排序？为什么从每个班级选出第一个学生就可以？这是因为`group by`（分组）只会取表中分组字段的第一条记录，而当我们将学生表按身高降序排序时，（每组）身高最高的学生就会出现在第一位。

执行如下 SQL 语句，进行测试：

```
-- 表子查询
select * from 
-- 关键字 from 后面接表名
(select * from student order by height desc) as student 
-- 按 c_id 进行分组
group by c_id;
```

![table](http://img.blog.csdn.net/20170827112336833)

由上面的 SQL 语句可知，表子查询也是`from`子查询，即有`select`语句位于`from`之后。


### 23.6 `exists`子查询

`exists`：表示是否存在的意思，因此`exists`子查询就是用来判断某些条件是否满足（跨表），`exists`是接在`where`之后，其返回的结果为`1`或`0`，满足条件为`1`，反之为`0`.

**需求**：在班级存在的前提下，查询所有的学生。

**思路**：

 - 先确定数据源。
  - `select * from student where ?;`
 - 然后确定条件是否满足。
  - `exists(select * from class);`

执行如下 SQL 语句，进行测试：

```
-- exists 子查询
select * from student where
exists(select * from class);

-- 添加限定条件，满足条件
select * from student where
exists(select * from class where id = 3);

-- 添加限定条件，不满足条件
select * from student where
exists(select * from class where id = 100);
```

![exists](http://img.blog.csdn.net/20170827120457531)

至此，我们已经将子查询学习完啦！也许大家还会有些疑惑，那就是到底在什么时候用什么子查询？对于这个问题，我们不用过于纠结，因为这根本就是我们要用什么子查询的问题，而是根据实际需求，我们将查询返回的结果按形式命名的称呼而已。

----------
**查询`class`表**：

![class](http://img.blog.csdn.net/20170826223402050)

**查询`student`表**：

![student](http://img.blog.csdn.net/20170827105224514)

----------

## 24. 视图 

**视图**：`view`，是一种有结构（有行有列），但没有结果（结构中不真实存放数据）的虚拟表，虚拟表的结构来源不是自己定义的，而是从对应的基表（视图的数据来源）中产生的。


### 24.1 创建视图

首先，给出创建视图的基本语法，

 - **基本语法**：`create view + 视图名 + as + select语句;`

其中，`select`语句可以是普通查询，也可以是连接查询、联合查询、子查询等。

此外，视图根据数据的来源，可以分为单表视图和多表视图：

 - 单表视图：基表只有一个；
 - 多表视图：基表至少两个。

执行如下 SQL 语句，进行测试：

```
-- 单表视图
create view my_v1 as select * from student;
create view my_v2 as select * from class;

-- 多表视图
create view my_v3 as
select * from student as s left join class c 
on s.c_id = c.id;
```

![1](http://img.blog.csdn.net/20170903173835484)

如上图所示，在我们创建多表视图的时候，由于表`student`和`class`中都含有`id`字段，因此导致出现错误“重复列名”。修改上述创建多表视图的 SQL 语句，继续进行测试：

```
-- 多表视图
create view my_v3 as
select s.*, c.grade, c.room from student as s left join class c 
on s.c_id = c.id;
```

![2](http://img.blog.csdn.net/20170903174232775)

如上图所示，当我们去掉表`class`中的`id`字段之后，成功创建多表视图。这是因为，当视图的基表有多张的时候，字段名不能重复。


### 24.2 查询视图

在这里，查询视图是指查看视图的结构，而不是查看视图的结果。

由于视图是一张虚拟表，因此表的所用查询语句，都适用于视图，例如：

 - `desc + 视图名;`
 - `show tables + 视图名;`
 - `show create table + 视图名;`

执行如下 SQL 语句，进行测试：

```
-- 查询视图
desc my_v1;
show create table my_v1;
```

![3](http://img.blog.csdn.net/20170903175912316)

虽然视图是虚拟表，但它和真正的表，至少在关键字上还是有区别的，因此在查询视图创建语句的时候，可以使用如下 SQL 语句：

```
-- 查询视图创建语句
show create view my_v1;
```

![4](http://img.blog.csdn.net/20170903180237267)

此外，视图一旦创建，系统就会在视图对应的数据库文件夹下创建一个对应的`frm`结构文件，以保证结构的完整性。



### 24.3 使用视图

在操作数据库表的过程中，使用视图，主要就是为了查询，因此将视图当做表一样查询即可。

在这里需要注意的是，虽然我们说视图是一个虚拟表，它不保存数据，但是它却可以获取数据。

执行如下 SQL 语句，进行测试：

```
-- 使用视图
select * from my_v1;
select * from my_v2;
select * from my_v3;
```

![5](http://img.blog.csdn.net/20170903181329186)

如上图所示，我们查询视图的结果和查询创建视图时`as`后面连接的`select`语句的结果完全相同。

因此，我们也可以认为：**创建视图，就是给一条`select`语句起别名，或者说是封装`select`语句**。

### 24.4 修改视图

视图本身不可修改，但是视图的来源（`select`）语句是可以修改的。因此，修改视图，就是修改视图的来源（`select`）语句。

 - **基本语法**：`alter view + 视图名 + as + 新的select语句;`

执行如下 SQL 语句，进行测试：

```
-- 修改视图
alter view my_v1 as
select id, name, gender, age, c_id from student;
```

![6](http://img.blog.csdn.net/20170903182832314)

### 24.5 删除视图

与视图的其他操作相比，删除视图比较简单，

 - **基本语法**：`drop view + 视图名;`

执行如下 SQL 语句，进行测试：

```
-- 删除视图
drop table my_v4;

-- 删除视图
drop view my_v4;
```

![6](http://img.blog.csdn.net/20170903185516278)

如上图所示，我们不能用

 - `drop table + 视图名;`

来删除视图，因为`table`包含真实的数据，而`view`说到底就是封装的`select`语句，并不包含真实的数据。虽然删除视图并不会影响数据，但在实际工作中，建议还是不要乱删别人建立的视图，因为视图封装的`select`语句很有可能包含复杂的业务逻辑。

### 24.6 视图意义

 - 视图可以节省 SQL 语句，将一条复杂的查询语句用视图来进行封装，以后可以直接对视图进行操作；
 - 数据安全，视图操作主要是针对查询的，如果对视图结构进行处理，例如删除，并不会影响基表的数据；
 - 视图往往在大型项目中使用，而且是多系统使用，可以对外提供有用的数据，但是隐藏关键（或无用）的数据；
 - 视图是对外提供友好型的，不同的视图提供不同的数据，就如专门对外设计的一样；
 - 视图可以更好（或者说，容易）的进行权限控制。


----------

## 25. 视图数据操作

**视图数据操作**：虽然我们说视图可以称之为`select`语句的别名，但实际上，它和别名并不一样，因为视图是可以进行数据写操作的，只不过有很多限制而已。

## 25.1 新增数据

在这里，新增数据就是指通过视图直接对基表进行数据的新增操作。

 - **限制 1**：多表视图不能进行新增数据。

执行如下 SQL 语句，进行测试：

```
-- 查询视图 my_v3 结构
desc my_v3;

-- 多表视图新增数据
insert into my_v3 values(7,'Gates','boy',2,170,'PM3.5','A315');
```

![1](http://img.blog.csdn.net/20170909134753471)

 - **限制 2**：可以向单表视图新增数据，但视图中包含的字段必须有基表中所有不能为空的字段。

执行如下 SQL 语句，进行测试：

```
-- 查询 student 表结构
desc student;

-- 创建视图 my_v4
create view my_v4 as
select id,name,age,c_id from student;

-- 单表视图新增数据
insert into my_v4 values(7,'Gates',25,2);
```

![2](http://img.blog.csdn.net/20170909141917265)

如上图所示，在我们新建的视图`my_v4`中，没有包含不能为空的字段`gender`，因此在我们向`my_v4`中新增数据的时候，报错。其实，这也很好理解，试想，在 MySQL 尝试将视图中新增的数据（一条记录）插入到基表的时候，忽然发现一个本不能为`null`的字段的值为默认值`null`，自然就会报错啦！反之，如果单表视图中包含了基表中的全部非空字段，自然可以插入成功。执行如下 SQL 语句，进行测试：

```
-- 查询 class 表数据
select * from class;

-- 创建视图 my_v5
create view my_v5 as
select * from class;

-- 单表视图新增数据
insert into my_v5 values(2,'PM2016','A315');

-- 查询 class 表数据
select * from class;
```

![3](http://img.blog.csdn.net/20170909143447416)

如上图所示，显然我们通过单表视图向基表中插入数据成功啦！


### 25.2 删除数据

与新增数据类似，

 - 多表视图不能删除数据；
 - 单表视图可以删除数据。

执行如下 SQL 语句，进行测试：

```
-- 查询多表视图 my_v3
select * from my_v3;

-- 删除多表视图 my_v3 中记录
delete from my_v3 where id = 2;

-- 查询单表视图 my_v5
select * from my_v5;

-- 删除单表视图 my_v5 中记录
delete from my_v5 where id = 2;

-- 查询单表视图 my_v5
select * from my_v5;
```

![4](http://img.blog.csdn.net/20170909145056989)

### 25.3 更新数据

理论上，无论多表视图还是单表视图，都可以进行数据的更新。

执行如下 SQL 语句，进行测试：

```
-- 查询单表视图 my_v5
select * from my_v5;

-- 更新单表视图 my_v5
update my_v5 set grade = 'PM2014' where id = 5;

-- 查询单表视图 my_v5
select * from my_v5;-- 查询单表视图 my_v5
select * from my_v5;

-- 更新单表视图 my_v5
update my_v5 set grade = 'PM2014' where id = 5;

-- 查询单表视图 my_v5
select * from my_v5;
```

![5](http://img.blog.csdn.net/20170909150303075)

此外，更新视图数据并不总是成功的，这是因为有**更新限制**的存在。那么何为更新限制呢？

 - 更新限制：`with check option`，如果创建视图的时候，设置了某个字段的限制，那么对视图进行更新操作的时候，系统就会进行验证，要保证更新之后，数据依然可以被查出来，否则不让更新。

执行如下 SQL 语句，进行测试：

```
-- 创建单表视图 my_v6
create view my_v6 as
select * from student where height > 170 with check option;

-- 查询单表视图 my_v6
select * from my_v6;

-- 更新单表视图 my_v6
update my_v6 set height = 165 where id = 6;
```

![6](http://img.blog.csdn.net/20170909151612737)


如上图所示，在更新视图的时候，更新失败，这是因为其违反了我们设置的更新限制。那么，视图之外的数据，我们能不能修改呢？执行如下 SQL 语句，进行测试：

```
-- 查询单表视图 my_v6
select * from my_v6;

-- 更新单表视图 my_v6
update my_v6 set height = 188 where id = 4;

-- 查询单表视图 my_v6
select * from my_v6;
```

![7](http://img.blog.csdn.net/20170909152042006)

如上图所示，更新视图`my_v6`之外数据的时候，显示成功。但是，待我们重新查询视图`my_v6`数据的时候，发现并没有真正更新成功。这是为什么呢？原因就在于我们不能通过视图去操作视图之外的数据。举一个不太恰当的例子，我们不能用自己手去操作别人兜里的钱啊！


## 26. 视图算法

视图算法，即系统对视图以及外部查询视图的`select`语句的一种解析方式。视图算法有三种，分别为：

 - `undefined`：未定义（默认的），这不是一种实际使用的算法，而是一个“推卸责任”的算法。在未定义的情况下，告诉系统，视图没有定义算法，请自己选择。
 - `temptable`：临时表算法，系统先执行视图的`select`语句，后执行外部查询语句。
 - `merge`：合并算法，系统先将视图对应的`select`语句与外部查询视图的`select`语句进行合并，然后再执行。此算法比较高效，且在未定义算法的时候，经常会默认选择此算法。

对于视图的算法，我们需要在创建视图的时候指定，

 - **基本语法**：`create + [algorithm = temptable/merge/undefined] + view + 视图名 + as + select语句;`

执行如下 SQL 语句，进行测试：

```
-- 查看视图 my_v2 的默认算法
show create view my_v2;

-- 指定视图 my_v7 算法为 temptable
create algorithm = temptable view my_v7 as
select * from student;

-- 查看视图 my_v7 的指定算法
show create view my_v7;
```

![8](http://img.blog.csdn.net/20170909163651397)

如上图所示，我们指定了视图`my_v7`的算法为`temptable`，但是对于算法的选择，我们该如何判断呢？答案是：如果视图的`select`语句中包含一个查询子句（五子句，包括`where`、`group by`、`order by` 、`having`和`limit`），而且很有可能查询子句的顺序比外部的查询语句的顺序要靠后（五子句的顺序），那么一定要使用`temptable`算法，其他情况可以不用指定，默认即可。

至此，我们已经将视图的内容大致讲完了。有一点需要我们特别注意，那就是：**视图最重要的功能就是查询，其他如增、删、改的操作一般不会使用，也不建议通过视图来操作基表的数据**。


----------

## 27. 数据备份还原

基础概念：

- **备份**，将当前已有的数据或记录另存一份；

- **还原**，将数据恢复到备份时的状态。

为什么要进行数据的备份与还原？

- 防止数据丢失；
- 保护数据记录。

数据备份与还原的方式有很多种，具体可以分为：数据表备份、单表数据备份、SQL备份和增量备份。

### 27.1 数据表备份

数据表备份，不需要通过 SQL 来备份，我们可以直接进入到数据库文件夹复制对应的表结构以及数据；在需要还原数据的时候，直接将备份（复制）的内容放回去即可。

不过想要进行数据表备份是有前提条件的，因为不同的存储引擎之间是有区别的。

对于存储引擎，MySQL 主要使用两种，分别为：**InnoDB** 和 **Myisam**，两者均免费。在这里，咱们可以顺便科普一下存储引擎的知识：

| 特点 | Myisam | InnoDB |BDB |Memory |Archive |
| :------------- |:-------------| :-----|  :------------- |:-------------| :-----|
|批量插入的速度 | 高 | 低 | 高 | 高 | 非常高 |
|事务安全 | —— | 支持 | 支持 | —— | —— |
| 全文索引 | 支持 | 5.5版本支持 | —— | —— | —— |
|锁机制 | 表锁 |行锁 |页锁 | 表锁 | 行锁 |
|存储限制 | 没有 | 64TB | 没有 | 有 | 没有 |
| B树索引 | 支持 |支持 |支持 | 支持 | —— |
|哈希索引 | —— |支持 | —— | 支持 | —— |
|集群索引 | —— | 支持 | ——| —— | —— |
| 数据缓存 | —— | 支持 |—— | 支持 | —— |
|索引缓存 | 支持 | 支持| —— | 支持 | —— |
|数据可压缩 | 支持 | —— | —— | —— | 支持 |
| 空间使用|低 | 高 | 低 | N/A | 非常低 |
|内存使用 | 低 | 高 | 低 | 中等 | 低 |
|外键支持 |—— | 支持 |—— | —— | —— |

其中，Myisam 和 InnoDB 的数据存储方法也有所区别：

- Myisam：表、数据和索引全部单独分开存储；
- InnoDB：只有表结构，数据全部存储到`ibd`文件中。

执行如下 SQL 语句，测试 Myisam 的数据存储方式：

```
-- 创建 Myisam 表
create table my_myisam(
	id int
)charset utf8 engine = myisam;

-- 显示表结构
show create table my_myisam;

-- 插入数据
insert into my_myisam values(1),(2),(3);

-- 显示数据
select * from my_myisam;
```

![1](http://img.blog.csdn.net/20171001124211791)

如上图所示，我们创建了名为`my_myisam`，存储引擎为 Myisam 的数据表。为了验证 Myisam 的存储特性，我们可以到`data`文件夹查看具体的数据存储情况：

![2](http://img.blog.csdn.net/20171001125044817)

如上图所示，我们仅仅创建了一个表`my_myisam`，但是 Myisam 对于会生成三个存储文件，分别为：

- `my_myisam.frm`：存储表的结构；
- `my_myisam.MYD`：存储表的数据；
- `my_myisam.MYI`：存储表的索引。

现在，我们将这三个文件复制到`testoo`数据库（至于如何找到 MySQL 数据文件的存储位置，可以参考[详述查看 MySQL 数据文件存储位置的方法](https://github.com/guobinhit/mysql-tutorial/blob/master/articles/datafile.md)）：

![3](http://img.blog.csdn.net/20171001125843845)

执行如下 SQL 语句，进行测试：

```
-- 切换数据库
use testoo;

-- 查看 testoo 数据库中的表
show tables;

-- 查看表 my_myisam
select * from my_myisam;
```

![4](http://img.blog.csdn.net/20171001125723307)

如上图所示，显然我们已经通过复制文件的方式，完成了数据表的备份工作。

在这里，有一点需要我们注意，那就是：**我们可以将通过 InnoDB 存储引擎产生的`.frm`和`.idb`文件复制到另一个数据库，也可以通过`show tables`命令查看复制过来的表名称，但是却无法获得数据**。

![5](http://img.blog.csdn.net/20171001130529481)

执行如下 SQL 语句，进行测试：

```
-- 查看 testoo 数据库中的表
show tables;

-- 查看表 my_class
select * from my_class;
```

![6](http://img.blog.csdn.net/20171001130643315)


通过以上测试，显然**数据表备份**这种备份方式更适用于 Myisam 存储引擎，而且备份的方式也很简单，直接复制 Myisam 存储引擎产生的`.frm`、`.MYD`和`.MYI`三个存储文件到新的数据库即可。

### 27.2 单表数据备份

单表数据备份，每次只能备份一张表，而且只能备份数据，不能备份表结构。

通常的使用场景为：将表中的数据导出到文件。

备份方法：从表中选出一部分数据保存到外部的文件中，

- `select */字段列表 + into outfile + '文件存储路径' + from 数据源;`

在这里，使用单表数据备份有一个前提，那就是：**导出的外部文件不存在，即文件存储路径下的文件不存在**。

执行如下 SQL 语句，进行测试：

```
-- 单表数据备份
select * into outfile 'D:/CoderLife/testMySQL/class.txt' from class;
```

![1](http://img.blog.csdn.net/20171001185200857)

如上图所示，SQL 语句已经执行成功。在这里，如果我们遇到：

> **ERROR 1290 (HY000)**: The MySQL server is running with the –secure-file-priv option so it cannot execute this statement.

这个错误，可以通过查看「[详述 MySQL 导出数据遇到 secure-file-priv 的问题](https://github.com/guobinhit/mysql-tutorial/blob/master/articles/secure.md)」进行解决。

为了验证是否真的将`class`表中的数据导出到指定位置，我们可以到该路径下进行确认：

![2](http://img.blog.csdn.net/20171001185637160)

如上图所示，显然我们已经将`class`表中的数据导出到本地啦！不过在这里，有一点需要我们特别注意，那就是：**对于从数据库导出的文件，我们最好用`EditPlus`等编辑工具打开，防止乱码**。

此外，对于上述用于导出表中数据的 SQL 语法，其实我们可以颠倒书写顺序，也没有问题，例如：

- `select */字段列表 + from 数据源 + into outfile + '文件存储路径';`

执行如下 SQL 语句，进行测试：

```
-- 单表数据备份
select * from class into outfile 'D:/CoderLife/testMySQL/class2.txt';
```

![3](http://img.blog.csdn.net/20171001190506222)

接下来，我们学习一些用于单表数据备份的高级操作，即**自己指定字段和行的处理方式**。

- **基本语法**：`select */字段列表 + into outfile + '文件存储路径' + fields + 字段处理 + lines + 行处理 + from 数据源;`

字段处理：

- `enclosed by`：指定字段用什么内容包裹，默认是` `，空字符串；
- `terminated by`：指定字段以什么结束，默认是`\t`，`Tab`键；
- `escaped by`：指定特殊符号用什么方式处理，默认是`\\`，反斜线转义。

行处理：

- `starting by`：指定每行以什么开始，默认是` `，空字符串；
-  `terminated by`：指定每行以什么结束，默认是`\r\n`，换行符。

执行如下 SQL 语句，进行测试：

```
-- 指定单表数据备份处理方式
select * into outfile 'D:/CoderLife/testMySQL/class3.txt'
-- 字段处理
fields
enclosed by '"'
terminated by '|'
lines
starting by 'START:'
from class ;
```

![4](http://img.blog.csdn.net/20171001192031438)

如上图所示，显然导出文件`class3.txt`按照我们指定的格式进行输出啦！在前面，我们已经测试了各种单表数据备份的方式，现在我们删除数据，并尝试还原数据，即**将保持在外部的数据重新恢复到数据表中**。But，由于单表数据备份仅能备份数据，因此如果表结构不存在，则不能进行还原。

- **基本语法**：`load data infile + '文件存储路径' + into table + 表名 + [字段列表] + fields + 字段处理 + lines + 行处理;`

执行如下 SQL 语句，进行测试：

```
-- 删除表 class 中的数据
delete from class;

-- 查看表 class 中的数据
select * from class;

-- 还原表 class 中的数据
load  data infile 'D:/CoderLife/testMySQL/class3.txt'
into table class
-- 字段处理
fields
enclosed by '"'
terminated by '|'
lines
starting by 'START:';

-- 查看表 class 中的数据
select * from class;
```

![5](http://img.blog.csdn.net/20171001193445728)

如上图所示，显然在我们删除表`class`中的数据之后，还原数据成功。

### 27.3 SQL 备份

SQL 备份，备份的是 SQL 语句。在进行 SQL 备份的时候，系统会对表结构以及数据进行处理，变成相应的 SQL 语句，然后执行备份。在还原的时候，只要执行备份的 SQL 语句即可，此种备份方式主要是针对表结构。

不过，MySQL 并没有提供 SQL 备份的指令，如果我们想要进行 SQL 备份，则需要利用 MySQL 提供的软件`mysqldump.exe`，而且`mysqldump.exe`也是一种客户端，因此在操作服务器的时候，必须进行认证。

- **基本语法**：`mysqldump.exe -hPup + 数据库名字 + [表名1 + [表名2]] > 备份文件目录`

其中，`-hPup`分别表示

- `h`：IP 或者`localhost`；
- `P`：端口号；
- `u`：用户名；
- `p`：密码。

由于`mysqldump.exe`也是客户端，因此想执行上述命令，我们需要先退出 MySQL 客户端，然后在命令行窗口执行如下命令：

```
mysqldump.exe -uroot -pbin.guo test class > D:/CoderLife/testMySQL/classSQL.sql
```

![1](http://img.blog.csdn.net/20171002111841764)

如上图所示，虽然`mysqldump`给出了警告（在命令行中输入密码是不安全的），但是我们输入的命令已经成功执行啦！在这里，如果执行上述命令不成功的话，很有可能是我们没有配置环境变量的问题。

![2](http://img.blog.csdn.net/20171002112024147)

如上图所示，在`testMySQL`目录下，已经生产了对表`class`的 SQL 备份，至于 SQL 备份的内容到底是什么，我们可以打开`classSQL.sql`文件进行查看：

![3](http://img.blog.csdn.net/20171002112300870)

如上图所示，通过 SQL 备份的文件，包含了各种 SQL 语句，如创建表的语句以及插入数据的语句等等。

此外，在上面给出的执行 SQL 备份的**基本语法**中，我们可以看到表名都用`[]`括了起来，这表示可选项，如果不输入表名，则默认备份整个数据库。执行过程和上面一样，因此我们就不予演示啦！

接下来，我们演示通过 SQL 备份的文件还原数据，有两种方式：

- **方式 1**：使用`mysql.exe`客户端还原数据
  - **基本语法**`mysql.exe/mysql -hPup 数据库名称 + 数据库名字 + [表名1 + [表名2]] < 备份文件目录`

在命令行窗口执行如下命令，进行测试：

```
-- 登录 MySQL 客户端
mysql -uroot -p

-- 输入密码，切换数据库
use test;

-- 删除表 class 中的数据
delete from class;

-- 退出数据库
\q

-- 通过 SQL 备份的文件还原数据
mysql -uroot -pbin.guo test < D:/CoderLife/testMySQL/classSQL.sql
```

![4](http://img.blog.csdn.net/20171002113939685)

如上图所示，上述命令全部执行成功。下面，我们检查还原结果，

![5](http://img.blog.csdn.net/20171002114030390)

如上图所示，显然表`class`的数据在删除之后，我们通过 SQL 备份的文件还原了数据。

- **方式 2**：使用 SQL 命令还原数据
  - **基本语法**`source + 备份文件目录;`

执行如上 SQL 语句，进行测试：

```
-- 查看表 class 数据
select * from class;

-- 删除表 class 数据
delete from class;

-- 查看表 class 数据
select * from class;

-- 通过 SQL 备份的文件还原数据
source D:/CoderLife/testMySQL/classSQL.sql;

-- 查看表 class 数据
select * from class;
```

![6](http://img.blog.csdn.net/20171002114807283)

![7](http://img.blog.csdn.net/20171002115002641)

如上图所示，显然表`class`的数据在删除之后，我们通过 SQL 备份的文件利用第二种方式还原了数据。

通过上面的学习及测试，我们可以知道 SQL 备份的优缺点：

- 优点：可以备份表结构；
- 缺点：增加额外的 SQL 命令，会浪费磁盘空间。


### 27.4 增量备份


增量备份，不是针对数据或者 SQL 进行备份，而是针对 MySQL 服务器的日志进行备份，其日志内容包括了我们对数据库的各种操作的历史记录，如增删改查等。此外，增量备份是指定时间段进行备份，因此备份的数据一般不会出现重复的情况，常用于大型项目的数据备份。在此，我们就不详细的进行介绍了，至于这部分的内容，以后会单独写一篇关于如何进行增量备份的博文。

----------

## 28. 事务

> **案例**：银行的数据库里面存储着用户的账户信息表，当用户 A 想用户 B 转账的时候，正常情况下，A 账户的余额减少，B 账户的余额增加；但是由于某种原因（例如突然断电），当 A 账户的余额减少之后，B 账户的余额并没有增加，这就造成了数据库数据的安全隐患。

> **解决方案**：当 A 账户的余额减少之后，不要立即修改数据表，而是在确认 B 账户的余额增加之后，同时修改数据表。


通过前面的案例及解决方案，我们就引出了一个全新的概念，那就是：**事务**，即

- 一系列将要发生或正在发生的连续操作。

而**事务安全，是一种保护连续操作同时实现（完成）的机制**。事务安全的意义就是，**保证数据操作的完整性**。

首先，执行如下 SQL 语句，创建银行账户表并插入数据：

```
-- 创建银行账户表
create table bank_account(
	id int primary key auto_increment,
	cardno varchar(16) not null unique comment 'bank card number',
	name varchar(20) not null,
	money decimal(10,2) default 0.0 comment 'account balance' 
)charset utf8;

-- 插入数据
insert into bank_account values
(null, '0000000000000001', 'Charies', 8000),
(null, '0000000000000002', 'Gavin', 6000);
```

![1](http://img.blog.csdn.net/20171021195300581)

接下来，让我们一起了解事务的操作。

事务操作，分为两种：**自动事务（默认的），手动事务**。

在这里，以银行账户的余额增减为例，我们来了解手动事务的操作流程。

**第 1 步**：开启事务，告诉系统以下所有操作，不要直接写入数据库，先存到事务日志。

- **基本语法**：`start transaction;`

执行如上 SQL 语句，开启事务：

```
-- 开启事务
start transaction;
```

![2](http://img.blog.csdn.net/20171021200426871)

**第 2 步**：减少 Charies 账户的余额

```
-- 更新 Charies 账户余额
update bank_account set money = money - 1000 where id = 1;
-- 查询 bank_account 表数据
select * from bank_account;
```

![3](http://img.blog.csdn.net/20171021201044152)

如上图所示，Charies 账户的余额显示减少`1000`，但实际上，由于我们开启了事务，数据表真实的数据，并没有同步更新。为了验证这个论断，我们重新打开一个数据库客户端，查询`bank_account`表的数据：

![4](http://img.blog.csdn.net/20171021201540765)

如上图所示，显然数据库的事务安全机制起了作用，当我们开启（手动）事务之后，其后一系列操作并没有直接写入数据库，而是存入了事务日志。在这里，我们并没有打开数据库事务的日志进行验证，因为事务日志存储的是经过编译之后的字节码文件。

**第 3 步**：增加 Gavin 账户的余额

```
-- 更新 Gavin 账户余额
update bank_account set money = money + 1000 where id = 2;
-- 查询 bank_account 表数据
select * from bank_account;
```

![5](http://img.blog.csdn.net/20171021202331094)

如上图所示，Gavin 账户的余额显示增加`1000`，但是，由于我们开启了事务，数据表真实的数据，仍然没有同步更新。

**第 4 步**：提交事务或回滚事务

- **提交事务基本语法**：`commit;`
- **回滚事务基本语法**：`rollback;`

如果我们选择提交事务，则将事务日志存储的记录直接更新到数据库，并清除事务日志；如果我们选择回滚事务，则直接将事务日志清除，所有在开启事务至回滚事务之间的操作失效，保持原有的数据库记录不变。在这里，我们以提交事务为例：

```
-- 提交事务
commit;
-- 查询 bank_account 表数据
select * from bank_account;
```

![6](http://img.blog.csdn.net/20171021203403955)

如上图所示，当我们提交事务之后，数据库的真实记录更新，两个客户端的数据一致。

在此，值得我们注意的是：**当我们提交事务之后，在进行回滚事务是不起作用的，因为事务日志在提交事务的同时已经被清除啦**！

此外，我们还要知道：**现阶段，只有 InnoDB 和 BDB 两个存储引擎是支持事务安全机制的**，其中 InnoDB 免费，BDB 收费。因此，InnoDB 使用的最为广泛。

----------

> **温馨提示**：在「[事务（上）](https://github.com/guobinhit/mysql-tutorial/blob/master/articles/thing-one.md)」中，我们已经了解了如何在 MySQL 中开启事务，以及事务的一些基本操作。在本文中，我们将进一步学习事务的知识，包括事务原理、自动事务、回滚点和事务特性等。

## 29. 事务原理

**事务原理**：在事务开启之后，所有的操作都会被临时存储到事务日志，事务日志只有在收到`commit`命令之后，才会将操作同步到数据表，其他任何情况都会清空事务日志，例如突然断开连接、收到`rollback`命令等。

接下来，我们简单分析一下 MySQL 的操作过程：

-  **Step 1**：客户端与服务端建立连接，同时开启一个临时的事务日志，此事务日志只作用于当前用户的当次连接；
-  **Step 2**：在客户端用 SQL 语句执行写操作，客户端收到 SQL 语句，执行，将结果直接写入到数据表，并将数据表同步到数据库；
-  **Step 3**：我们在客户端开启事务，则服务端原来的操作机制被改变，后续所有操作都会被先写入到临时日志文件；
-  **Step 4**：在客户端执行 SQL 语句（例如写操作），服务端收到 SQL 语句，执行，将结果写入到临时日志文件，并不将结果同步到数据库；
-  **Step 5**：在客户端执行查询操作，服务端直接从临时日志文件中捞取数据，返回给客户端；
- **Step 6**：在客户端执行`commit`或者`rollback`命令，清空临时日志文件，如果是`commit`命令，则将结果同步到数据库；如果是`rollback`命令，则不同步。

通过上面的分析，我们就知道了为什么在我们同时开启两个 MySQL 客户端窗口（两次连接）时，当一个窗口开启事务并执行 SQL 操作之后，另一个窗口在查询时并不会收到同步数据。原因就在于，当我们开启事务之后，服务端会将后续的操作都写入到临时日志文件，而另一个窗口在查询的时候，则是直接从数据库捞取数据，并会不走前一个的临时日志文件。

### 29.1 回滚点

**回滚点**：在某个操作成功完成之后，后续的操作有可能成功也有可能失败，但无论后续操作的结果如何，前一次操作都已经成功了，因此我们可以在当前成功的位置，设置一个操作点，其可以供后续操作返回该位置，而不是返回所有操作，这个点称之为回滚点。关于回滚点的基本语法为，

  - **设置回滚点**：`savepoint + 回滚点名称;`
  - **返回回滚点**：`rollback to + 回滚点名称;`

执行如下 SQL 语句，进行测试：

```
-- 测试回滚点
-- 查询 bank_account 表数据
select * from bank_account;

-- 开启事务
start transaction;

-- 事务操作 1：给 Charies 发工资 1000 元
update bank_account set money = money + 10000 where id = 1;

-- 设置回滚点
savepoint spone;

-- 银行扣税：错误
update bank_account set money = money - 10000 * 0.05 where id = 2;

-- 查询 bank_account 表数据
select * from bank_account;
```

![save](http://img.blog.csdn.net/20171118105029691)

执行如下 SQL 语句，继续进行测试：

```
-- 测试回滚点
-- 返回回滚点
rollback to spone;

-- 银行扣税：正确
update bank_account set money = money - 10000 * 0.05 where id = 1;

-- 查询 bank_account 表数据
select * from bank_account;

-- 提交事务
commit;
```

![rollback](http://img.blog.csdn.net/20171118105228230)

如上图所示，显然在执行返回回滚点的操作之后，我们之前的错误操作得到了修正。

### 29.2 自动事务

在 MySQL 中，默认的都是自动事务处理，即用户在操作完成之后，其操作结果会立即被同步到数据库中。

自动事务是通过`autocommit`变量控制的，我们可以通过如下 SQL 语句，进行查看：

```
-- 查询自动事务
show variables like 'autocommit';
```

![autocommit](http://img.blog.csdn.net/20171118105830583)

如上图所示，此为 MySQL 的默认设置。实际上，我们可以自己选择是否开启自动事务处理，其基本语法为，

- **开启自动事务处理**：`set autocommit = on / 1;`
- **关闭自动事务处理**：`set autocommit = off / 0;`

在此，我们以关闭自动事务处理为例，进行演示：

```
-- 关闭自动事务处理
set autocommit = 0;

-- 查看自动事务处理
show variables like 'autocommit';

-- 查看 bank_account 表数据
select * from bank_account;

-- 修改 bank_account 表数据
update bank_account set money = money + 1000 where id = 1;

-- 查看 bank_account 表数据
select * from bank_account;
```

![0ff](http://img.blog.csdn.net/20171118110823688)

如上图所示，我们并没有开启事务，仅是关闭了自动事务处理，但是我们发现，在我们修改了`bank_account`表中数据之后，其结果并不会立即同步到数据库。实际上，这就是关闭了自动事务处理的正常现象。在我们执行`commit`命令之后，上述操作的结果即可进行同步：

```
-- 提交
commit;

-- 查看 bank_account 表数据
select * from bank_account;
```

![commit](http://img.blog.csdn.net/20171118111322094)


当然，如果我们不执行`commit`命令，而是执行`rollback`命令，那么之前的所用操作都会回滚到初始的状态。在此，我们需要注意的是：**通常情况下，我们是应该开启自动事务处理的，否则的话，每次操作完成之后都需要我们手动提交，那岂不是要被累死了**？

### 29.3 事务特性

事务的特性，可以简单的概括为`ACID`，具体为：

- **原子性**：`Atomic`，表示事务的整个操作是一个整体，是不可分割的，要么全部成功，要么全部失败；
- **一致性**：`Consistency`，表示事务操作的前后，数据表中的数据处于一致状态；
- **隔离性**：`Isolation`，表示不同的事务操作之间是相互隔离的，互不影响；
- **持久性**：`Durability`，表示事务一旦提交，将不可修改，永久性的改变数据表中的数据。

对于上述事务的四个特性，其中原子性、一致性、持久性比较容易理解，但是隔离性却需要格外注意。例如，开启两个客户端窗口，分别执行如下 SQL 语句，进行测试：

```
-- 演示隔离性操作：窗口 1
-- 开始事务
start transaction;

-- 修改 id 为 1 的数据
update bank_account set money = money + 666 where id = 1;

-- 查看 bank_account 表数据
select * from bank_account;

---------   万人迷分割线   ---------

-- 演示隔离性操作：窗口 2
-- 开始事务
start transaction;

-- 修改 id 为 2 的数据
update bank_account set money = money + 666 where id = 2;

-- 查看 bank_account 表数据
select * from bank_account;
```

![isolation](http://img.blog.csdn.net/20171118115845872)

如上图所示，其完美的展示了事务隔离性的效果，即窗口 1 的中的事务操作，没有影响到窗口 2 的事务操作；窗口 2 的中的事务操作，也没有影响到窗口 1 的事务操作。But，在我们执行下面的 SQL 语句之后，我们将会看到不同的效果：

```
-- 演示隔离性操作：窗口 1
-- 开始事务
start transaction;

-- 修改 name 为 Charies 的数据
update bank_account set money = money + 666 where name = 'Charies';

-- 查看 bank_account 表数据
select * from bank_account;

---------   万人迷分割线   ---------

-- 演示隔离性操作：窗口 2
-- 开始事务
start transaction;

-- 修改 name 为 Gavin 的数据
update bank_account set money = money + 666 where name = 'Gavin';

-- 查看 bank_account 表数据
select * from bank_account;
```

![geli](http://img.blog.csdn.net/20171118120618537)

如上图所示，窗口 1 的事务可以正常执行，但是窗口 2 的事务开启成功，但是在修改数据的时候被“卡”住了，并且在持续一段时间之后，报出了一个 `Lock wait timeout exceeded`的错误：

![geliiiii](http://img.blog.csdn.net/20171118120759846)

那么到底是什么原因导致了上述错误的发生呢？这就是涉及到了数据库的另外一个知识点 **锁机制** 啦！

实际上，MySQL 使用的默认存储引擎是 InnoDB，而 InnoDB 默认使用的锁机制是 **行锁**（锁住操作的当前行），但是如果在事务操作的过程中，我们没有使用索引字段，那么系统就会自动进行全表检索，也就是其自动将行锁升级为 **表锁**（锁住操作的当前表）。

现在回想一下，我们在第一次测试的时候，使用的条件`id`为主键索引，所以两个事务可以表示出很好的隔离性，互不影响；在第二次测试的时候，我们将条件换为`name`，而`name`并不是索引字段，因此在第二次测试的时候，窗口 1 的事务使用了表锁，锁住了整张表，而在事务提交或回滚之前，其并不释放锁，所以所有试图修改被锁住表的数据的操作，都会陷入等待状态。等待超时，自然就报错啦！

对于锁机制，在「[基础教程](https://github.com/guobinhit/mysql-tutorial)」篇，我们并不做过多的介绍，在后续的「[性能优化](https://github.com/guobinhit/mysql-tutorial)」篇中在详细的进行讨论。

----------


## 30. 变量

在 MySQL 数据库中，变量有两种，分别为：**系统变量**和**自定义变量**。

根据变量的作用范围，又分为：

 - **会话级别变量**：仅对当前客户端当次连接有效；
 - **全局级别变量**：对所有客户端的任一次连接都有效。

### 30.1 系统变量

系统变量，顾名思义，是系统设置好的变量（皆为全局级别变量），也是用来控制服务器表现的，如`autocommit`、`wait_timeout`等。

大多数的时候，我们并不需要使用系统变量，但我们仍然需要了解有这么回事，在必须要的时候，它可以帮助我们完成特殊的需求。

首先，查看系统变量，语法为：

- **基本语法**：`show variables;`

执行如下 SQL 语句，进行测试：

```
-- 查看系统变量
show variables;
```

![systemvariable](http://img.blog.csdn.net/20171203193555417)

如上图所示，显示了 MySQL 在本服务器上共含有 506 个系统变量。更近一步，我们可以查看具体的系统变量的值，语法为：

- **基本语法**：`select + @@变量名 + [, @@变量名, ... , @@变量名];`

执行如下 SQL 语句，进行测试：

```
-- 查看具体的系统变量的值
select @@autocommit,@@version,@@version_compile_os,@@wait_timeout;
```

![variablevalus](http://img.blog.csdn.net/20171203194217805)

如上图所示，我们查到了具体的变量的值。此外，**任何一个有内容返回的查询操作都是用`select`来完成的**。

接下来，我们尝试修改系统变量，先修改会话级别变量，再修改全局级别变量。

对于修改会话级别变量，有两种方法，语法分别为：

- **基本语法 1**：`set 变量名 = 值;`
- **基本语法 2**：`set @@变量名 = 值;`

执行如下 SQL 语句，进行测试：

```
-- 设置会话级别变量
set autocommit = 0;
set @@wait_timeout = 20000;

-- 查看系统变量
select @@autocommit, @@wait_timeout;
```

![modify](http://img.blog.csdn.net/20171203200203284)

如上图所示，我们修改了`autocommit`和`wait_timeout`的值，但仅作用于会话级别，即只有当前当次连接有效，当再次打开一个新窗口的时候，我们会发现所有的变量值都恢复如初。

对于修改全局级别变量，语法为：

- **基本语法**：`set global 变量名 = 值;`

执行如下 SQL 语句，进行测试：

```
-- 设置全局级别变量
set global autocommit = 0;

-- 查看系统变量
select @@autocommit;
```

![global](http://img.blog.csdn.net/20171203201139818)

如上图所示，当我们修改全局变量的时候，其效果对所有客户端的任一次连接都有效。But，如果某一个客户端在我们修改全局变量之前已经连上了服务器并且没有退出的话，那么我们的修改对其当前当次连接无效，需要重新登录才能生效。

### 30.2 自定义变量

自定义变量，顾名思义，是用户自己定义的变量，并且都是会话级别的变量。

系统为了区别系统变量与自定义变量，规定**用户自定义的变量必须使用一个`@`符号**。设置自定义变量的语法为：

- **基本语法**：`set @变量名 = 值;`

执行如下 SQL 语句，进行测试：

```
-- 设置自定义变量
set @name = 'binguo';

-- 查看自定义变量
select @name;
```

![selfvariable](http://img.blog.csdn.net/20171203202631796)

观察上图，我们会发现查看自定义变量和系统变量有些细微的区别，那就是：查看系统变量时，`select`后面是跟着`@@`的，而查看自定义变量时，`select`后面是跟着`@`的。在这里，我们需要注意：**在 MySQL 中，很多地方会默认将`=`处理为比较符号，因此 MySQL 还提供了另外一种赋值符号`:=`，即冒号与等号拼接而成的符号**。

此外，MySQL 允许我们从数据表中获取数据，然后直接赋值给变量，共有两种方式，分别为：

**第 1 种**：边赋值，边查看结果。语法为

- **基本语法**：`select @变量名 := 字段名 from 表名;`

执行如下 SQL 语句，进行测试：

```
-- 从数据表中获取数据，然后直接为自定义变量赋值
select @name = name from student;

-- 查看自定义变量
select @name;
```

![name](http://img.blog.csdn.net/20171203203833634)

如上图所示，呃，这是什么鬼？好吧，细心的同学估计已经发现了，在上面的`select`语句中，我们误将`:=`写为`=`啦，然后 MySQL 将`=`处理为比较符号，并且在`student`表中没有发现与`binguo`匹配的名字，因此显示的结果皆为`0`，如果匹配成功，则会显示`1`。下面，我们修改赋值符号，重新进行测试：

```
-- 从数据表中获取数据，然后直接为自定义变量赋值
select @name := name from student;

-- 查看自定义变量
select @name;
```

![fuzhifuhao](http://img.blog.csdn.net/20171203204410183)

如上图所示，我们会发现上述`select`语句的作用为：从`student`表读取数据，然后依次赋值给自定义变量`@name`，并且先赋的值会被覆盖，仅保留最后一个赋值结果。

**第 2 种**：只赋值，不查看结果。语法为

- **基本语法**：`select  + 字段列表 + from + 表名 + into + 变量列表;`

执行如下 SQL 语句，进行测试：

```
-- 从数据表中获取数据，然后直接为自定义变量赋值
select name from student into @name;

-- 查看自定义变量
select @name;

-- 查看 student 表数据
select * from student;
```

![errorinto](http://img.blog.csdn.net/20171203211108688)


如上图所示，显然`EEROR`，内容为：返回结果包含的内容超过一列。实际上，在未加限制条件的情况下，我们直接从表中捞取数据，是捞取全部数据，因此忽略上述 SQL 语句中的`into @name`，其返回的结果为表中的全部`name`值，自然是超过一个了。在这种情况下，系统会报错，却将捞取数据的第一个值赋值给了`@name`，也就是说，在捞取数据超过一条记录的时候，系统会默认将第一个值赋值给自定义变量。

虽然上述 SQL 语句修改了`@name`的值，但却是一种错误的赋值方式，也是不可控的，其结果往往并不是我们想要的。对于上述的赋值方式，MySQL 的要求比较严格，规定每次只能获取一条记录。因此正确的做法是，加上一个`where`条件，将查询的结果限制为一条，例如

```
-- 从数据表中获取数据，然后直接为自定义变量赋值
select name from student where id = 2 into @name;

-- 查看自定义变量
select @name;
```

![rightinto](http://img.blog.csdn.net/20171203205939649)

如上图所示，我们获取数据并赋值成功。

最后，在强调一点：**自定义变量都是会话级别，只要是当前用户当次连接，都会受到影响，不区分数据库**。


----------

## 31. 触发器

> **案例**：网上购物，根据生产订单的类型，商品的库存量对应的进行增和减。此案例涉及两张表，分别为订单表和商品表，下单时，商品表库存减少；退单时，商品表库存增加。如何实现？


**触发器**：`trigger`，是指**事先为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行**。

触发器包含三个要素，分别为

- 事件类型：增删改，即`insert`、`delete`和`update`；
- 触发时间：事件类型前和后，即`before`和`after`；
- 触发对象：表中的每一条记录（行），即`整张表`。

每张表只能拥有一种触发时间的一种事件类型的触发器，即**每张表最多可以拥有 6 种触发器**。

### 31.1 创建触发器

```
-- 创建触发器基本语法
delimiter 自定义符号 -- 临时修改语句结束符，在后续语句中只有遇到自定义符号才会结束语句
create trigger + 触发器名称 + 触发器时间 + 事件类型 on 表名 for each row
begin -- 代表触发器内容开始
-- 触发器内容主体，每行用分号结尾
end -- 代表触发器内容结束
自定义符号 -- 用于结束语句
delimiter ; -- 恢复语句结束符
```

根据上述案例的需求，我们先来创建两张表，分别为商品表`goods`和订单表`orders`，SQL 语句如下：

```
-- 创建商品表
create table goods(
	id int primary key auto_increment,
	name varchar(20) not null,
	price decimal(10, 2) default 0,
	inventory int comment '商品库存量'
)charset utf8;

-- 插入两条数据
insert into goods values(null, 'iPhone8', 5088, 1000), (null, 'iPhoneX', 8088, 1000);

-- 创建订单表
create table orders(
	id int primary key auto_increment,
	goods_id int not null,
	goods_number int default 1
)charset utf8;
```
![createtables](http://img.blog.csdn.net/20180101171434839)

接下来，执行如下 SQL 语句，创建触发器：

```
-- 创建触发器
delimiter $$ -- 临时修改语句结束符
create trigger after_order after insert on orders for each row
begin -- 触发器内容开始
	-- 触发器内容主体，每行用分号结尾
	update goods set inventory = inventory - 1 where id = 1;
end -- 触发器内容结束
$$ -- 结束语句
delimiter ; -- 恢复语句结束符
```
![createtrigger](http://img.blog.csdn.net/20180101173413160)

### 31.2 查询触发器

查询所有触发器或模糊匹配，

- **基本语法**：`show triggers + [like 'pattern'];`

执行如下 SQL 语句，进行测试：

```
-- 查询所有触发器，\G 表示旋转
show triggers\G;
```
![showtrigger](http://img.blog.csdn.net/20180101174439535)

当然，我们也可以查询创建触发器的语句

- **基本语法**：`show create trigger + 触发器名称;`

执行如下 SQL 语句，进行测试：

```
-- 查询触发器创建语句，\G 表示旋转
show create trigger after_order\G;
```
![sqltrigger](http://img.blog.csdn.net/20180101174709988)

此外，**所有的触发器都会被系统保持到`information_schema.triggers`这张表中**，执行如下 SQL，进行测试：
```
-- 查询触发器，\G 表示旋转
select * from information_schema.triggers\G;
```
![oooo](http://img.blog.csdn.net/20180101185148483)

### 31.3 使用触发器

实际上，触发器不是我们手动触发的，而是在某种情况发生的时候自动触发，例如我们上面创建的`after_order`触发器，当我们`insert`订单表的时候，该触发器自动执行。执行如下 SQL 语句，进行测试：

```
-- 查看商品表
select * from goods;
-- 查看订单表
select * from orders;
-- 插入订单表
insert into orders values(null, 2, 10);
-- 查看订单表
select * from orders;
-- 查看商品表
select * from goods;
```
![usetrigger](http://img.blog.csdn.net/20180101181034152)

观察上图，我们会发现：触发器确实生效了，在我们向`orders`表`insert`数据的时候，`goods`表发生了变化；但是其并没有如我们期望那样执行，就算我们将`goods_id`设置为`2`，`goods_number`设置为`10`，触发器操作的仍然是`goods`表中`id`为 `1`的记录且库存量只减`1`。且先不提这个问题，在创建触发器的时候，我们要特别注意：**触发器的触发对象和事件类型，决不能同触发器主体的内容相同，防止发生死循环**。

### 31.4 修改触发器 & 删除触发器

**触发器不能修改，只能删除**。因此，当我们需要修改触发器的时候，唯一的方法就是：先删除，后新增。

- **基本语法**：`drop trigger + 触发器名称;`

执行如下 SQL 语句，进行测试：

```
-- 删除触发器
drop trigger after_order;
-- 查询触发器
show triggers;
```

![deletetrigger](http://img.blog.csdn.net/20180101182826645)

### 31.5 触发器记录

触发器记录：无论触发器是否触发，只要当某种操作准备执行，系统就会将当前操作的记录的当前状态和即将执行之后的状态分别记录下来，供触发器使用。其中，当前状态被保存到`old`中，操作之后的状态被保存到`new`中。至于`old`和`new`是什么鬼？不知道大家是否还记得查看表`information_schema.triggers`的时候，标红的两个字段：

- `ACTION_REFERENCE_OLD_ROW：OLD`
- `ACTION_REFERENCE_NEW_ROW：NEW`

其中，

- `OLD`，代表是旧记录，也就是当前记录的状态，插入时没有`OLD`；
- `NEW`，代表是新记录，也就是假设操作发生之后记录的状态，删除时没有`NEW`。

无论`OLD`还是 `NEW`，都代表记录本身，而且任何一条记录除了有数据，还有字段名。因此，使用`OLD`和 `NEW`的方法就是：

- **基本语法**：`OLD/NEW + . + 字段名`

在这里，我们就能够通过触发器记录解决刚才`after_order`触发器的问题了。依次执行如下 SQL 语句，进行测试：

```
-- 创建新触发器
delimiter $$ -- 临时修改语句结束符
create trigger after_order_new after insert on orders for each row
begin -- 触发器内容开始
	-- 触发器内容主体，每行用分号结尾
	update goods set inventory = inventory - NEW.goods_number where id = NEW.goods_id;
end -- 触发器内容结束
$$ -- 结束语句
delimiter ; -- 恢复语句结束符

-- 查看新触发器
show triggers\G;
```

![newtrigger](http://img.blog.csdn.net/20180101190739091)

```
-- 查看商品表
select * from goods;
-- 查看订单表
select * from orders;
-- 插入订单表
insert into orders values(null, 2, 10);
-- 查看订单表
select * from orders;
-- 查看商品表
select * from goods;
```
![testnewtrigger](http://img.blog.csdn.net/20180101190855572)

如上图所示，显然`after_order_new`触发器按我们预期那样正确的工作啦！

----------


## 32. 代码执行结构

在 MySQL 编程中，代码的执行结构有三种，分别为：

- 顺序结构；
- 分支结构；
- 循环结构。

顺序结构，自不必多说，在本文中，我们着重了解分支结构和循环结构。

### 32.1 分支结构

**分支结构**：事先准备多个代码块，通过判断条件是否满足，执行对应的代码。

在 MySQL 中，只有`if`分支结构，其基本语法为：

```
if 条件判断 then
	-- 满足条件时，要执行的代码
else -- 可以没有 else 语句
	-- 不满足条件时，要执行的代码
end if;
```
接下来，我们利用触发器和`if`分支，完成这样的需求：

- 在生成订单前，判断商品的库存是否满足，如果满足，则插入订单；否则，插入失败。

依次执行如下 SQL 语句，进行测试：

```
-- 查看商品表
select * from goods;
-- 查看订单表
select * from orders;
-- 修改语句结束符
delimiter $$
-- 创建触发器
create trigger before_order before insert on orders for each row
begin
	-- 判断商品库存是否满足订单
	-- 通过商品表获取商品库存量
	select inventory from goods where id = NEW.goods_id into @inventory;
	-- 比较库存
	if @inventory < NEW.goods_number then
		-- 库存不够，由于触发器不能阻止事件发生，因此我们只能暴力报错
		insert into XXX values(XXX);
	end if;
end
$$
-- 恢复语句结束符
delimiter ;	
```

![01](http://img.blog.csdn.net/20180103220140999)

```
-- 插入订单
insert into orders values(null, 1, 1000);
-- 查看商品表
select * from goods;
-- 查看订单表
select * from orders;
```

![02](http://img.blog.csdn.net/20180103220216878)

```
-- 插入订单
insert into orders values(null, 1, 100);
-- 查看商品表
select * from goods;
-- 查看订单表
select * from orders;
```

![03](http://img.blog.csdn.net/20180103220401645)

如上图所示，虽然在报错的时候，没有给出友好的提示信息，但我们已经实现了该需求。

### 32.2 循环结构

**循环结构**：表示某段代码在指定条件下进行重复执行动作。

在 MySQL 中，没有`for`循环，仅有`while`循环、`loop`循环和`repeat`循环，呃，还有一种非标准的`goto`循环，在此我们仅介绍`while`循环，其基本语法为：

```
while 条件判断 do
	-- 满足条件时要执行的代码
	-- 变更循环条件
end while;
```
在使用循环结构的时候，我们经常需要对循环进行控制，即在循环结构内部进行判断和控制。虽然在 MySQL 中没有`continue`和`break`，但是有其替代关键字：

- `iterate`：迭代，类似于`continue`，表示结束本次循环，不执行后续步骤，直接开始下一次循环；
- `leave`：离开，类似于`break`，直接结束整个循环。

上述两个关键字的使用方法为，

- **基本语法**：`iterate/leave + 循环名称;`

因此，在我们定义循环结构的时候，就需要进行略微的修改了，具体形式如下：

```
循环名称: while 条件判断 do
	-- 满足条件时要执行的代码
	-- 变更循环条件
	iterate/leave 循环名称; -- 控制循环语句
end while;
```

由于触发器只能执行简单的一次触发动作，因此不适合演示循环结构。循环结构需要结合`函数`进行使用，所以在介绍函数的时候，我们再来体验循环结构的魅力。

----------


## 33. 函数

**函数**，就是将一段代码封装到一个结构中，在需要执行该段代码的时候，直接调用该结构（函数）执行即可。此操作，实现了代码的复用。在 MySQL 中，函数有两种，分别为：系统函数和自定义函数。

### 33.1 系统函数

顾名思义，系统函数就是系统定义好的函数，在需要的时候，我们直接调用即可。

任何函数都有返回值（对于空函数，我们就认为其返回值为`空`），而且在 MySQL 中任何有返回值的操作都是通过`select`来操作的，因此 MySQL 的函数调用就是通过`select`来实现的。

在 MySQL 中，字符是字符串操作中最常见的基本单位。此外，如果对中文的截取是按字节进行的话，很容易造成乱码的问题。

下面，我们介绍一些常见的、对字符进行操作的系统函数：首先，执行如下语句，定义一些变量，

```
set @cn = '你好世界';
set @en = 'hello world';
set @one = 'charies';
set @two = 'gavin';
set @three = 'Gavin';

select @cn, @en, @one, @two, @three;
```

![1](http://img.blog.csdn.net/2018030312401492)

然后，调用系统函数进行测试：

- `substring`，截取字符串，单位为字符；

![2](http://img.blog.csdn.net/20180303124316330)

如上图所示，在 MySQL 中字符串的位置是从`1`开始，`0`含有特殊的意义。


- `char_length`，获取字符长度；
- `length`，获取字节长度；

![3](http://img.blog.csdn.net/2018030312461235)

- `instr`，判断字符串中某个子串是否存在，存在则返回具体的位置，不存在则返回`0`；

![4](http://img.blog.csdn.net/20180303125417272)

- `lpad`，左填充，将字符串按照某个指定的填充方式，填充到指定（字符）长度；

![5](http://img.blog.csdn.net/2018030312594361)

如上图所示，在对`@en`进行填充的时候，填充结果为`hellohellhello world`，其中第二个`hello`并没有填充全，这是因为系统函数`lpad`的第二个参数限定的了变量`@en`的具体长度，如示例中我们设置其为`20`，而原`@en`的长度为`11`，因此只能向`@en`中在填充`9`个字符。

- `insert`，找到目标位置，将指定长度的字符串替换为目标字符串；

![6](http://img.blog.csdn.net/2018030313100113)

如上图所示，`insert`函数并没有修改变量自身的值，只是对变量的值进行加工而已。

- `strcmp`，比较字符串的大小；

![7](http://img.blog.csdn.net/20180303131400954)

如上图所示，在用`strcmp`函数对字符串进行比较的时候不区分大小写（默认校对集），并用`0`表示两个字符串相等；用`-1`表示第一个参数的字符串小于第二个参数的字符串；用`1`表示第一个参数的字符串大于第二个参数的字符串。

### 33.2 自定义函数

对于任意一个函数，其都包含如下要素：

- 函数名；
- 参数类别（可以为空）；
- 返回值；
- 函数体（作用域）。

根据上面这些函数要素，我们就来尝试创建自定义函数。

### 33.3 创建函数

```
-- 基本语法
create function 函数名([参数列表]) returns 数据类型
begin
	-- 函数体
	-- 返回值，类型为 returns 指定的数据类型
end
```
 如果我们定义的函数的函数体内仅含有返回值，则可以省略`begin`和`end`。此外，自定义函数和系统函数的调用方式相同。执行如下语句，进行测试：

```
-- 自定义函数
create function showLove() returns int
return 521;
-- 调用自定义函数
select showLove();
```
![8](http://img.blog.csdn.net/20180303134415202)

### 33.4 查看函数

查看函数，基本语法为：

- `show function status + [like 'pattern'];`

![9](http://img.blog.csdn.net/20180303135209908)

如上图所示，我们可以看到`showLove`函数是属于`test`数据库的，这引出了函数的一个性质，即**函数是属于具体数据库的，在一个数据库定义的函数不能在其定义的数据库外使用，但是可以查看**。

查看函数的创建语句，基本语法为：

- `show create function + 函数名;`

![10](http://img.blog.csdn.net/2018030313543411)

### 33.5 修改函数 & 删除函数

函数只能先删除后新增，不能修改。删除函数的基本语法为：

- `drop function + 函数名;`

执行如下语句，进行测试：

```
-- 删除函数
drop function showLove;
-- 查看函数
show function status like 'showLove'\G;
```

![11](http://img.blog.csdn.net/20180303135927583)

### 33.6 函数参数

对于函数的参数，一共有两种，分别为形参和实参，其中，形参可以理解为定义函数时使用的参数，且形参必须指定数据类型；实参可以理解为在调用函数时传入的值或变量。因此，函数定义的具体形式应该为：

- `function 函数名(形参名字 形参类型) returns 返回数据类型`

下面，我们定义一个函数，完成一个简单的需求，即求`1`到指定数值的和。代码如下：

```
delimiter $$
create function addAll(num int) returns int
begin
	-- 定义条件变量
	set @i = 1;
	set @res = 0;    -- 保存求和结果
	-- 循环求和
	while @i <= num do
		-- 任何变量想要修改值都必须使用 set 关键字，且 MySQL 中没有 += 或者 ++ 运算符
		set @res = @res + @i;
		-- 修改循环变量
		set @i = @i + 1;
	end while;
	-- 返回求和结果
	return @res;
end
$$
delimiter ;
```

![12](http://img.blog.csdn.net/20180303142308376)

如上图所示，函数已经定义成功。接下来，执行如下语句，进行测试：

```
-- 调用函数求和
select addAll(100);

-- 查询自定义变量 @res 和 @i
select @res, @i;
```
![13](http://img.blog.csdn.net/20180303142619986)

如上图所示，求和函数`addAll`已经正确执行。此外，我们发现在函数内部使用`@`符号定义的变量`@res`和`@i`在函数外部也是可以查看使用的，这说明：**使用`@`符号定义的变量为全局变量**。

### 33.7 变量作用域

在 MySQL 中，变量的作用域有两种，分别为全局和局部，其中，全局变量可以在任何地方使用；局部变量只能在函数内部使用。

- 全局变量：使用`set`关键字定义，用`@`符号标识；
- 局部变量：使用`declare`关键字声明，且所用的局部变量必须在函数体开始之前进行声明。

接下来，我们利用局部变量定义一个函数，完成一个简单的需求，即求`1`到指定数值的和，要求`10`的倍数不加。代码如下：

```
delimiter $$
create function addAll2(num int) returns int
begin
	-- 声明变量，包含循环变量和结果变量
	declare i int default 1;    -- 定义局部变量可以含有属性
	declare res int default 0;
	-- 循环求和
	mywhile:while i <= num do
		-- 条件判断
		if i % 10 = 0 then
			-- 修改循环变量
			set i = i + 1;
			-- 重新循环
			iterate mywhile;
		end if;
		-- 修改结果变量
		set res = res + i;
		-- 修改循环变量
		set i = i + 1;
	end while;
	-- 返回求和结果
	return res;
end
$$
delimiter ;
```

![14](http://img.blog.csdn.net/20180303145957621)

如上图所示，函数已经定义成功。接下来，执行如下语句，进行测试：

```
-- 调用函数求和
select addAll(100), addAll2(100);
```
![15](http://img.blog.csdn.net/20180303150125572)

如上图所示，函数已经正确执行。

----------

## 34.存储过程

存储过程简称过程，`procedure`，是一种用来处理数据（增删改）的方式。简单点，我们也可以将其理解为没有返回值的函数。

### 34.1 创建过程

```
-- 基本语法
create procedure 过程名([参数列表])
begin
	-- 过程体
end
```
如果我们定义的过程的过程体内仅含有一条语句，则可以省略`begin`和`end`。执行如下语句，进行测试：

```
-- 创建过程
create procedure pro()
select * from student;
```

![16](http://img.blog.csdn.net/20180303152317511)

如上图所示，我们创建了一个名为`pro()`的过程，其目的就是为了查询`student`表中的数据。但实际上，过程多用于处理数据，查询并不多用。

### 34.2 查看过程

查看过程，基本语法为：

- `show procedure status + [like 'pattern'];`

![17](http://img.blog.csdn.net/20180303152637538)

查看过程的创建语句，基本语法为：

- `show create procedure + 过程名;`

![18](http://img.blog.csdn.net/20180303152744196)

### 34.3 调用过程

由于函数有返回值，因此我们可以用`select`来调用函数。但是存储过程没有返回值，怎么办？实际上，对于存储过程，有一个专门的调用关键字`call`，调用过程的基本语法为：

- `call + 过程名;`

![19](http://img.blog.csdn.net/20180303153024878)

### 34.4 修改过程 & 删除过程

过程只能先删除后新增，不能修改。删除过程的基本语法为：

- `drop procedure + 过程名;`

执行如下语句，进行测试：

```
-- 删除过程
drop procedure pro;
-- 查看过程
show procedure status like 'pro'\G;
```

![20](http://img.blog.csdn.net/20180303153409873)

### 34.5 过程参数

函数的参数需要指定数据类型，过程比函数更加严格。过程有三种自己的参数类型，分别为：

- `in`，数据只是从过程外部传入给过程内部使用，可以是数值也可以是变量；
- `out`，此参数只能传递变量，且变量指向的数据需要先清空然后才能进入过程内部，该引用供过程内部使用，过程结束后可以将变量的值传递给过程外部使用；
- `inout`，此参数只能传递变量，该变量的值可以给过程内部使用，过程结束后可以变量的值传递给过程外部使用。

因此，过程定义的具体形式应该为：

- `procedure 过程名(in 参数名字 参数类型, out 参数名字 参数类型, inout 参数名字 参数类型)`

下面，我们定义一个简单的过程，并调用过程。代码如下：

```
delimiter $$
create procedure pro2(in var1 int, out var2 int, inout var3 int)
begin
	-- 查看该过程传入的三个变量
	select var1, var2, var3;
end
$$
delimiter ;

-- 调用过程
call pro2(1,2,3);
```

![21](http://img.blog.csdn.net/20180303165150957)

如上图所示，过程`pro2`创建成功。但是，在调用过程的时候出现错误，造成该错误的原因为：过程的`out`和`inout`两个参数只能接受变量，而我们传递了具体的数值，报错也就在情理之中啦！接下来，执行如下语句，进行测试：

```
-- 设置全局变量
set @var1 = 1;
set @var2 = 2;
set @var3 = 3;

-- 调用过程
call pro2(@var1, @var2, @var3);
-- 查看变量
select @var1, @var2, @var3;
```

![22](http://img.blog.csdn.net/20180303165813193)

如上图所示，在我们将变量传递给过程的时候，过程正常执行。此外，通过`select`语句我们可以看到传递给`out`类型参数的`@var2`的值在经过过程处理之后，被置为`null`值啦，这也是符合`out`类型参数的先清空后使用原则的。而且，由于`out`和`inout`只能接受变量作为参数，因此在过程内部对`out`和`inout`传入的变量的修改会影响到过程外部。在这里，值得我们注意是：存储过程对变量的操作是滞后的，即**只有在过程结束的时候，才会将过程内部修改的值赋值给外部传入的对应的全局变量**。执行如下语句，进行测试：

```
delimiter $$
create procedure pro3(in var1 int, out var2 int, inout var3 int)
begin
	-- 查看该过程传入的三个变量
	select var1, var2, var3;
	-- 修改局部变量
	set var1 = 10;
	set var2 = 20;
	set var3 = 30;
	-- 查看局部变量
	select var1, var2, var3;
	-- 查看全局变量
	select @var1, @var2, @var3;	
	-- 修改全局变量
	set @var1 = 'a';
	set @var2 = 'b';
	set @var3 = 'c';
	-- 查看全局变量
	select @var1, @var2, @var3;		
end
$$
delimiter ;
```

![23](http://img.blog.csdn.net/20180303171216448)

```
-- 调用过程
call pro3(@var1, @var2, @var3);
-- 在过程结束后，查看全局变量
select @var1, @var2, @var3;
```

![24](http://img.blog.csdn.net/20180303171506912)

如上图所示，存储过程执行成功，且验证了我们结论，即：**在存储过程没有结束的时候，对传入变量的修改并不会影响到对应的全局变量；只有在存储过程结束后，才会将对应的变量值赋值给`out`和`inout`类型的变量，而`in`类型的变量不受影响**。

----------




